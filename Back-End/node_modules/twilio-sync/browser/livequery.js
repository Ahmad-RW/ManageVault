"use strict";

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var queryItems = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(params) {
        var network, jsonQuery, queryString, uri, liveQueryRequestBody, response;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        network = params.network, jsonQuery = params.jsonQuery, queryString = params.queryString, uri = params.uri;
                        liveQueryRequestBody = {
                            query: jsonQuery,
                            query_string: queryString // raw query string (like `key == "value" AND key2 != "value2"`)
                        };
                        _context.next = 4;
                        return network.post(uri, liveQueryRequestBody, undefined, true);

                    case 4:
                        response = _context.sent;
                        return _context.abrupt("return", response.body);

                    case 6:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function queryItems(_x) {
        return _ref.apply(this, arguments);
    };
}();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("./utils");
var parser = require("./lql/parser");
var utils = require("./lql/utils");
var uuidv4 = require("uuid/v4");
var events_1 = require("events");
var syncerror_1 = require("./syncerror");
var entity_1 = require("./entity");
var logger_1 = require("./logger");

var InsightsItem = function InsightsItem() {
    (0, _classCallCheck3.default)(this, InsightsItem);
};

exports.InsightsItem = InsightsItem;

var LiveQueryProxy = function (_entity_1$SyncEntity) {
    (0, _inherits3.default)(LiveQueryProxy, _entity_1$SyncEntity);

    function LiveQueryProxy(descriptor, services, removalHandler) {
        (0, _classCallCheck3.default)(this, LiveQueryProxy);

        var _this = (0, _possibleConstructorReturn3.default)(this, (LiveQueryProxy.__proto__ || (0, _getPrototypeOf2.default)(LiveQueryProxy)).call(this, services, removalHandler));

        _this.descriptor = descriptor;
        _this.attachedLiveQueries = new _map2.default();
        return _this;
    }
    // public


    (0, _createClass3.default)(LiveQueryProxy, [{
        key: "onRemoved",

        // dummy stub from iface
        value: function onRemoved() {}
    }, {
        key: "_update",
        value: function _update(update, isStrictlyOrdered) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(this.attachedLiveQueries.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var liveQuery = _step.value;

                    liveQuery._update(update);
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }
        }
    }, {
        key: "attach",
        value: function attach(liveQuery) {
            var uuid = liveQuery.listenerUuid;
            var existingRecord = this.attachedLiveQueries.get(uuid);
            if (existingRecord) {
                return;
            }
            if (!this.attachedLiveQueries.size) {
                // the first one to arrive
                this._subscribe();
            }
            this.attachedLiveQueries.set(uuid, liveQuery);
        }
    }, {
        key: "detach",
        value: function detach(listenerUuid) {
            this.attachedLiveQueries.delete(listenerUuid);
            if (!this.attachedLiveQueries.size) {
                // last one out, turn off lights, shut the door
                this.close(); // invokes unsubscribe and removal handler
            }
        }
    }, {
        key: "sid",
        get: function get() {
            return this.descriptor.sid;
        }
        // private extension of SyncEntity

    }, {
        key: "uniqueName",
        get: function get() {
            return null;
        }
    }, {
        key: "type",
        get: function get() {
            return LiveQueryProxy.type;
        }
    }, {
        key: "lastEventId",
        get: function get() {
            return null;
        }
    }, {
        key: "indexName",
        get: function get() {
            return this.descriptor.indexName;
        }
    }, {
        key: "jsonQuery",
        get: function get() {
            return this.descriptor.jsonQuery;
        }
    }, {
        key: "queryString",
        get: function get() {
            return this.descriptor.queryExpression;
        }
        // custom private props

    }, {
        key: "queryUri",
        get: function get() {
            return this.descriptor.queryUri;
        }
    }, {
        key: "liveQueryDescriptor",
        get: function get() {
            return this.descriptor;
        }
    }, {
        key: "network",
        get: function get() {
            return this.services.network;
        }
    }], [{
        key: "type",
        get: function get() {
            return 'live_query';
        }
    }]);
    return LiveQueryProxy;
}(entity_1.SyncEntity);

exports.LiveQueryProxy = LiveQueryProxy;
function parseQueryExpression(newQuery) {
    try {
        var tree = parser.parseLiveQuery(newQuery);
        return utils.binaryTreeToQueryJson(tree);
    } catch (e) {
        throw new syncerror_1.SyncError("Invalid query syntax: '" + e.message + "'", 400, 54507);
    }
}
exports.parseQueryExpression = parseQueryExpression;

exports.queryItems = queryItems;
function handleItems(items) {
    if (items) {
        return items.reduce(function (mapAcc, item) {
            mapAcc[item.key] = {
                key: item.key,
                value: item.data,
                revision: item.revision
            };
            return mapAcc;
        }, {});
    }
}
/**
 * @class
 * @alias LiveQuery
 * @classdesc Represents a long-running query against Flex data wherein the returned result set
 *     subsequently receives pushed updates whenever new (or updated) records would match the
 *     given expression. Updated results are presented row-by-row until this query is explicitly
 *     unsubscribed.
 *
 *     Use the {@link Client#liveQuery} method to create a live query.
 *
 * @property {String} sid The immutable identifier of this query object, assigned by the system.
 *
 * @fires LiveQuery#itemUpdated
 * @fires LiveQuery#itemRemoved
 */

var LiveQuery = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(LiveQuery, _events_1$EventEmitte);
    (0, _createClass3.default)(LiveQuery, [{
        key: "type",
        get: function get() {
            return LiveQueryProxy.type;
        }
        // custom private props

    }, {
        key: "listenerUuid",
        get: function get() {
            return this.uuid;
        }
        // public

    }, {
        key: "sid",
        get: function get() {
            return this.proxy.sid;
        }
        /**
         * @private
         */

    }], [{
        key: "type",
        get: function get() {
            return LiveQueryProxy.type;
        }
    }]);

    function LiveQuery(proxy, items) {
        (0, _classCallCheck3.default)(this, LiveQuery);

        var _this2 = (0, _possibleConstructorReturn3.default)(this, (LiveQuery.__proto__ || (0, _getPrototypeOf2.default)(LiveQuery)).call(this));

        _this2.proxy = proxy;
        _this2.uuid = uuidv4();
        _this2.items = handleItems(items);
        _this2.proxy.attach(_this2);
        return _this2;
    }
    /**
     * Closes this query instance and unsubscribes from further service events.
     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.
     * @public
     */


    (0, _createClass3.default)(LiveQuery, [{
        key: "close",
        value: function close() {
            this.items = {};
            this.proxy.detach(this.uuid);
        }
        /**
         * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.
         * @public
         */

    }, {
        key: "getItems",
        value: function getItems() {
            var _this3 = this;

            var dataByKey = {};
            if (this.items) {
                (0, _keys2.default)(this.items).map(function (key, index) {
                    dataByKey[key] = _this3.items[key].value;
                });
            }
            return dataByKey;
        }
        /**
         * @private
         */

    }, {
        key: "_update",
        value: function _update(message) {
            var key = message.item_key;
            var revision = message.item_revision;
            switch (message.type) {
                case 'live_query_item_updated':
                    var existingItem = this.items[key];
                    if (!existingItem || revision > existingItem.revision) {
                        var newItem = { key: key, revision: revision, value: message.item_data };
                        this.items[key] = newItem;
                        this.emit('itemUpdated', newItem);
                    }
                    break;
                case 'live_query_item_removed':
                    delete this.items[key];
                    this.emit('itemRemoved', { key: key });
                    break;
            }
        }
    }]);
    return LiveQuery;
}(events_1.EventEmitter);

exports.LiveQuery = LiveQuery;
/**
 * @class
 * @alias InstantQuery
 * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a
 * LiveQuery, this result set does not subscribe to any updates and therefore receives no events
 * beyond the initial result set.
 *
 * Use the {@link Client#instantQuery} method to create an Instant Query.
 *
 * @fires InstantQuery#searchResult
 */

var InstantQuery = function (_events_1$EventEmitte2) {
    (0, _inherits3.default)(InstantQuery, _events_1$EventEmitte2);

    /**
     * @private
     */
    function InstantQuery(params) {
        (0, _classCallCheck3.default)(this, InstantQuery);

        var _this4 = (0, _possibleConstructorReturn3.default)(this, (InstantQuery.__proto__ || (0, _getPrototypeOf2.default)(InstantQuery)).call(this));

        _this4.queryExpression = null;
        (0, _assign2.default)(_this4, params);
        _this4.updateIndexName(params.indexName);
        return _this4;
    }
    // private props


    (0, _createClass3.default)(InstantQuery, [{
        key: "search",

        /**
         * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}
         * event.
         * @param {String} queryExpression A query expression to be executed against the given data index. For more information
         * on the syntax read {@link Client#liveQuery}.
         * @returns {Promise<void>} A promise that resolves when query result has been received.
         * @public
         */
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(queryExpression) {
                var _this5 = this;

                var newQuery;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                newQuery = void 0;
                                _context2.prev = 1;

                                newQuery = parseQueryExpression(queryExpression);
                                _context2.next = 8;
                                break;

                            case 5:
                                _context2.prev = 5;
                                _context2.t0 = _context2["catch"](1);
                                return _context2.abrupt("return", _promise2.default.reject(_context2.t0));

                            case 8:
                                return _context2.abrupt("return", queryItems({
                                    network: this.network,
                                    uri: this.queryUri,
                                    jsonQuery: newQuery,
                                    queryString: queryExpression
                                }).then(function (response) {
                                    _this5.queryExpression = queryExpression;
                                    _this5.items = handleItems(response.items);
                                    _this5.emit('searchResult', _this5.getItems());
                                }).catch(function (err) {
                                    logger_1.default.error("Error '" + err.message + "' while executing query '" + (0, _stringify2.default)(newQuery) + "'");
                                    _this5.queryExpression = null;
                                    throw err;
                                }));

                            case 9:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this, [[1, 5]]);
            }));

            function search(_x2) {
                return _ref2.apply(this, arguments);
            }

            return search;
        }()
        /**
         * Instantiates a LiveQuery object based on the last known query expression that was passed to the
         * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,
         * while current object can be still used to execute repetitive searches.
         * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.
         * @public
         */

    }, {
        key: "subscribe",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                return _context3.abrupt("return", this.liveQueryCreator(this.indexName, this.queryExpression));

                            case 1:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function subscribe() {
                return _ref3.apply(this, arguments);
            }

            return subscribe;
        }()
        /**
         * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.
         * @public
         */

    }, {
        key: "getItems",
        value: function getItems() {
            var _this6 = this;

            var dataByKey = {};
            if (this.items) {
                (0, _keys2.default)(this.items).map(function (key, index) {
                    dataByKey[key] = _this6.items[key].value;
                });
            }
            return dataByKey;
        }
        /**
         * Set new index name
         * @param {String} indexName New index name to set
         * @returns void
         * @public
         */

    }, {
        key: "updateIndexName",
        value: function updateIndexName(indexName) {
            if (!indexName || typeof indexName !== 'string') {
                throw new Error('Index name must contain a non-empty string value');
            }
            this.indexName = indexName;
            this.queryUri = this.generateQueryUri(this.indexName);
        }
    }, {
        key: "generateQueryUri",
        value: function generateQueryUri(indexName) {
            return new utils_1.UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment('Items').build();
        }
    }, {
        key: "type",
        get: function get() {
            return InstantQuery.type;
        }
    }], [{
        key: "type",
        get: function get() {
            return 'instant_query';
        }
    }]);
    return InstantQuery;
}(events_1.EventEmitter);

exports.InstantQuery = InstantQuery;
exports.default = LiveQuery;
/**
 * @class InsightsItem
 * @classdesc An individual result from a LiveQuery or InstantQuery result set.
 * @property {String} key The identifier that uniquely identifies this item within the search result.
 * @property {Object} value The contents of the item.
 */
/**
 * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a
 * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of
 * {@link InsightsItem}-s.
 * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot
 */
/**
 * Fired when an item has been added or updated.
 * @event LiveQuery#itemUpdated
 * @param {InsightsItem} item Updated item.
 * @example
 * liveQuery.on('itemUpdated', function(item) {
 *   console.log('Item ' + item.key + ' was updated');
 *   console.log('Item value: ', item.value);
 * });
 */
/**
 * Fired when an existing item has been removed.
 * @event LiveQuery#itemRemoved
 * @param {Object} args Arguments provided with the event.
 * @param {String} args.key The key of the removed item.
 * @example
 * liveQuery.on('itemRemoved', function(args) {
 *   console.log('Item ' + args.key + ' was removed');
 * });
 */
/**
 * Fired when a search result is ready.
 * @event InstantQuery#searchResult
 * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.
 * @example
 * instantQuery.on('searchResult', function(items) {
 *    Object.entries(items).forEach(([key, value]) => {
 *      console.log('Search result item key: ' + key);
 *      console.log('Search result item value: ' + value);
 *    });
 * });
 */