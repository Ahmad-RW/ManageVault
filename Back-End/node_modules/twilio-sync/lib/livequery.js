"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const parser = require("./lql/parser");
const utils = require("./lql/utils");
const uuidv4 = require("uuid/v4");
const events_1 = require("events");
const syncerror_1 = require("./syncerror");
const entity_1 = require("./entity");
const logger_1 = require("./logger");
class InsightsItem {
}
exports.InsightsItem = InsightsItem;
class LiveQueryProxy extends entity_1.SyncEntity {
    constructor(descriptor, services, removalHandler) {
        super(services, removalHandler);
        this.descriptor = descriptor;
        this.attachedLiveQueries = new Map();
    }
    // public
    get sid() { return this.descriptor.sid; }
    // private extension of SyncEntity
    get uniqueName() { return null; }
    get type() { return LiveQueryProxy.type; }
    static get type() { return 'live_query'; }
    get lastEventId() { return null; }
    get indexName() { return this.descriptor.indexName; }
    get jsonQuery() { return this.descriptor.jsonQuery; }
    get queryString() { return this.descriptor.queryExpression; }
    // custom private props
    get queryUri() { return this.descriptor.queryUri; }
    get liveQueryDescriptor() { return this.descriptor; }
    get network() { return this.services.network; }
    // dummy stub from iface
    onRemoved() { }
    _update(update, isStrictlyOrdered) {
        for (const liveQuery of this.attachedLiveQueries.values()) {
            liveQuery._update(update);
        }
    }
    attach(liveQuery) {
        const uuid = liveQuery.listenerUuid;
        const existingRecord = this.attachedLiveQueries.get(uuid);
        if (existingRecord) {
            return;
        }
        if (!this.attachedLiveQueries.size) {
            // the first one to arrive
            this._subscribe();
        }
        this.attachedLiveQueries.set(uuid, liveQuery);
    }
    detach(listenerUuid) {
        this.attachedLiveQueries.delete(listenerUuid);
        if (!this.attachedLiveQueries.size) {
            // last one out, turn off lights, shut the door
            this.close(); // invokes unsubscribe and removal handler
        }
    }
}
exports.LiveQueryProxy = LiveQueryProxy;
function parseQueryExpression(newQuery) {
    try {
        const tree = parser.parseLiveQuery(newQuery);
        return utils.binaryTreeToQueryJson(tree);
    }
    catch (e) {
        throw new syncerror_1.SyncError(`Invalid query syntax: '${e.message}'`, 400, 54507);
    }
}
exports.parseQueryExpression = parseQueryExpression;
async function queryItems(params) {
    let { network, jsonQuery, queryString, uri } = params;
    const liveQueryRequestBody = {
        query: jsonQuery,
        query_string: queryString // raw query string (like `key == "value" AND key2 != "value2"`)
    };
    let response = await network.post(uri, liveQueryRequestBody, undefined, true);
    return response.body;
}
exports.queryItems = queryItems;
function handleItems(items) {
    if (items) {
        return items.reduce((mapAcc, item) => {
            mapAcc[item.key] = {
                key: item.key,
                value: item.data,
                revision: item.revision
            };
            return mapAcc;
        }, {});
    }
}
/**
 * @class
 * @alias LiveQuery
 * @classdesc Represents a long-running query against Flex data wherein the returned result set
 *     subsequently receives pushed updates whenever new (or updated) records would match the
 *     given expression. Updated results are presented row-by-row until this query is explicitly
 *     unsubscribed.
 *
 *     Use the {@link Client#liveQuery} method to create a live query.
 *
 * @property {String} sid The immutable identifier of this query object, assigned by the system.
 *
 * @fires LiveQuery#itemUpdated
 * @fires LiveQuery#itemRemoved
 */
class LiveQuery extends events_1.EventEmitter {
    static get type() { return LiveQueryProxy.type; }
    get type() { return LiveQueryProxy.type; }
    // custom private props
    get listenerUuid() { return this.uuid; }
    // public
    get sid() { return this.proxy.sid; }
    /**
     * @private
     */
    constructor(proxy, items) {
        super();
        this.proxy = proxy;
        this.uuid = uuidv4();
        this.items = handleItems(items);
        this.proxy.attach(this);
    }
    /**
     * Closes this query instance and unsubscribes from further service events.
     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.
     * @public
     */
    close() {
        this.items = {};
        this.proxy.detach(this.uuid);
    }
    /**
     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.
     * @public
     */
    getItems() {
        const dataByKey = {};
        if (this.items) {
            Object.keys(this.items).map((key, index) => {
                dataByKey[key] = this.items[key].value;
            });
        }
        return dataByKey;
    }
    /**
     * @private
     */
    _update(message) {
        const key = message.item_key;
        const revision = message.item_revision;
        switch (message.type) {
            case 'live_query_item_updated':
                const existingItem = this.items[key];
                if (!existingItem || revision > existingItem.revision) {
                    const newItem = { key, revision, value: message.item_data };
                    this.items[key] = newItem;
                    this.emit('itemUpdated', newItem);
                }
                break;
            case 'live_query_item_removed':
                delete this.items[key];
                this.emit('itemRemoved', { key });
                break;
        }
    }
}
exports.LiveQuery = LiveQuery;
/**
 * @class
 * @alias InstantQuery
 * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a
 * LiveQuery, this result set does not subscribe to any updates and therefore receives no events
 * beyond the initial result set.
 *
 * Use the {@link Client#instantQuery} method to create an Instant Query.
 *
 * @fires InstantQuery#searchResult
 */
class InstantQuery extends events_1.EventEmitter {
    /**
     * @private
     */
    constructor(params) {
        super();
        this.queryExpression = null;
        Object.assign(this, params);
        this.updateIndexName(params.indexName);
    }
    // private props
    static get type() { return 'instant_query'; }
    get type() { return InstantQuery.type; }
    /**
     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}
     * event.
     * @param {String} queryExpression A query expression to be executed against the given data index. For more information
     * on the syntax read {@link Client#liveQuery}.
     * @returns {Promise<void>} A promise that resolves when query result has been received.
     * @public
     */
    async search(queryExpression) {
        let newQuery;
        try {
            newQuery = parseQueryExpression(queryExpression);
        }
        catch (err) {
            return Promise.reject(err);
        }
        return queryItems({
            network: this.network,
            uri: this.queryUri,
            jsonQuery: newQuery,
            queryString: queryExpression
        })
            .then(response => {
            this.queryExpression = queryExpression;
            this.items = handleItems(response.items);
            this.emit('searchResult', this.getItems());
        })
            .catch(err => {
            logger_1.default.error(`Error '${err.message}' while executing query '${JSON.stringify(newQuery)}'`);
            this.queryExpression = null;
            throw err;
        });
    }
    /**
     * Instantiates a LiveQuery object based on the last known query expression that was passed to the
     * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,
     * while current object can be still used to execute repetitive searches.
     * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.
     * @public
     */
    async subscribe() {
        return this.liveQueryCreator(this.indexName, this.queryExpression);
    }
    /**
     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.
     * @public
     */
    getItems() {
        const dataByKey = {};
        if (this.items) {
            Object.keys(this.items).map((key, index) => {
                dataByKey[key] = this.items[key].value;
            });
        }
        return dataByKey;
    }
    /**
     * Set new index name
     * @param {String} indexName New index name to set
     * @returns void
     * @public
     */
    updateIndexName(indexName) {
        if (!indexName || typeof indexName !== 'string') {
            throw new Error('Index name must contain a non-empty string value');
        }
        this.indexName = indexName;
        this.queryUri = this.generateQueryUri(this.indexName);
    }
    generateQueryUri(indexName) {
        return new utils_1.UriBuilder(this.insightsUri)
            .pathSegment(indexName)
            .pathSegment('Items')
            .build();
    }
}
exports.InstantQuery = InstantQuery;
exports.default = LiveQuery;
/**
 * @class InsightsItem
 * @classdesc An individual result from a LiveQuery or InstantQuery result set.
 * @property {String} key The identifier that uniquely identifies this item within the search result.
 * @property {Object} value The contents of the item.
 */
/**
 * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a
 * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of
 * {@link InsightsItem}-s.
 * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot
 */
/**
 * Fired when an item has been added or updated.
 * @event LiveQuery#itemUpdated
 * @param {InsightsItem} item Updated item.
 * @example
 * liveQuery.on('itemUpdated', function(item) {
 *   console.log('Item ' + item.key + ' was updated');
 *   console.log('Item value: ', item.value);
 * });
 */
/**
 * Fired when an existing item has been removed.
 * @event LiveQuery#itemRemoved
 * @param {Object} args Arguments provided with the event.
 * @param {String} args.key The key of the removed item.
 * @example
 * liveQuery.on('itemRemoved', function(args) {
 *   console.log('Item ' + args.key + ' was removed');
 * });
 */
/**
 * Fired when a search result is ready.
 * @event InstantQuery#searchResult
 * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.
 * @example
 * instantQuery.on('searchResult', function(items) {
 *    Object.entries(items).forEach(([key, value]) => {
 *      console.log('Search result item key: ' + key);
 *      console.log('Search result item value: ' + value);
 *    });
 * });
 */
