"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function blockPostTreatment(startTypeName, tree) {
    if (!tree || !tree.lexeme) {
        return tree;
    }
    if (tree.lexeme.type === startTypeName) {
        tree.lexeme = {
            type: tree.left.lexeme.type,
            value: tree.left.lexeme.value
        };
        if (!tree.lexeme.value) {
            delete tree.lexeme.value;
        }
        tree.right = tree.left.right;
        tree.left = tree.left.left;
    }
    blockPostTreatment(startTypeName, tree.right);
    blockPostTreatment(startTypeName, tree.left);
    return tree;
}
exports.blockPostTreatment = blockPostTreatment;
function commaPostTreatment(startTypeName, tree) {
    if (!tree || !tree.lexeme) {
        return tree;
    }
    commaReplacer(startTypeName, tree, tree);
    return tree;
}
exports.commaPostTreatment = commaPostTreatment;
function isBlockLexeme(type) {
    return type === 'startArray' || type === 'startBlock';
}
function commaReplacer(startTypeName, treeTop, treeCurrent) {
    if (!treeCurrent || !treeCurrent.lexeme) {
        return treeCurrent;
    }
    let replacer = isBlockLexeme(treeCurrent.lexeme.type) ? treeTop : treeCurrent;
    if (treeCurrent.lexeme.type === startTypeName) {
        replacer = treeTop; // pass the top replacing node down to the bottom
        treeCurrent.lexeme.type = replacer.lexeme.type;
    }
    commaReplacer(startTypeName, replacer, treeCurrent.right);
    commaReplacer(startTypeName, replacer, treeCurrent.left);
    return treeCurrent;
}
