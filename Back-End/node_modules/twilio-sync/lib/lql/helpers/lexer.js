"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function generateRegexp(lexeme) {
    return new RegExp('^(' + lexeme.regexp + ')', lexeme.modifiers);
}
exports.generateRegexp = generateRegexp;
function generateCutLexer(type, length) {
    return function (str, lexemesArray) {
        lexemesArray.push({
            type: type,
            value: str.slice(0, length)
        });
        return str.slice(length);
    };
}
exports.generateCutLexer = generateCutLexer;
function endOfString(str, quoted, spaces, first, endLexemes) {
    if (str.length === 0) {
        return true;
    }
    else if (quoted) {
        return str.charAt(0) === '"';
    }
    else if (spaces.indexOf(str.charAt(0)) !== -1 ||
        str.charAt(0) === '"') {
        return true;
    }
    if (first) {
        return false;
    }
    return endLexemes.some(function (lexeme) {
        return generateRegexp(lexeme).test(str);
    });
}
function stringLexer(endLexemes) {
    return function (str, lexemesArray, spaces) {
        let first = true;
        let quoted = false;
        let value = '';
        if (str.charAt(0) === '"') {
            quoted = true;
            str = str.slice(1);
        }
        while (!endOfString(str, quoted, spaces, first, endLexemes)) {
            if (str.charAt(0) === '\\') {
                value += str.charAt(1);
                str = str.slice(2);
                continue;
            }
            value += str.charAt(0);
            str = str.slice(1);
            first = false;
        }
        if (quoted && str.charAt(0) !== '"') {
            throw new Error('Cannot reach end of quoted string');
        }
        else if (quoted) {
            str = str.slice(1);
        }
        lexemesArray.push({
            type: 'string',
            value: value
        });
        return str;
    };
}
exports.stringLexer = stringLexer;
function endOfAttr(str, spaces, first, endLexemes) {
    if (str.length === 0) {
        return true;
    }
    else if (spaces.indexOf(str.charAt(0)) !== -1) {
        return true;
    }
    if (first) {
        return false;
    }
    return endLexemes.some(function (lexeme) {
        return generateRegexp(lexeme).test(str);
    });
}
function attrLexer(endLexemes) {
    return function (str, lexemesArray, spaces) {
        let first = true;
        let value = '';
        while (!endOfAttr(str, spaces, first, endLexemes)) {
            if (str.charAt(0) === '\\') {
                value += str.charAt(1);
                str = str.slice(2);
                continue;
            }
            value += str.charAt(0);
            str = str.slice(1);
            first = false;
        }
        lexemesArray.push({
            type: 'attr',
            value: value
        });
        return str;
    };
}
exports.attrLexer = attrLexer;
function clearSpaces(str, spaces) {
    let i = 0;
    while (i < str.length && spaces.indexOf(str.charAt(i)) !== -1) {
        i += 1;
    }
    return str.slice(i);
}
exports.clearSpaces = clearSpaces;
