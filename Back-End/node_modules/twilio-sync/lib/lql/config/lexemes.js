"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lexerHelper = require('../helpers/lexer');
const syntaxerHelper = require('../helpers/syntaxer');
const postHelper = require('../helpers/post');
const andLexeme = {
    regexp: 'and(\\s|\\(|"|$)',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('and', 3),
    syntaxer: syntaxerHelper.andSyntaxer,
    priority: 4,
    checker: { negative: ['endBlock', null] }
};
exports.and = andLexeme;
const andAmpersandLexeme = {
    regexp: '&&',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('and', 2),
    syntaxer: syntaxerHelper.andSyntaxer,
    priority: 4,
    checker: { negative: ['endBlock', null] }
};
exports.andAmpersand = andAmpersandLexeme;
const orLexeme = {
    regexp: 'or(\\s|\\(|"|$)',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('or', 2),
    syntaxer: syntaxerHelper.orSyntaxer,
    priority: 5,
    checker: { negative: ['endBlock', null] }
};
exports.or = orLexeme;
const orVerticalBarLexeme = {
    regexp: '\\|\\|',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('or', 2),
    syntaxer: syntaxerHelper.orSyntaxer,
    priority: 5,
    checker: { negative: ['endBlock', null] }
};
exports.orVerticalBar = orVerticalBarLexeme;
const equalLexeme = {
    regexp: 'eq(\\s|\\(|"|$)',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('eq', 2),
    syntaxer: syntaxerHelper.eqSyntaxer,
    priority: 3,
    checker: { mandatory: ['string', null] }
};
exports.eq = equalLexeme;
const equalDoubleSignLexeme = {
    regexp: '==',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('eq', 2),
    syntaxer: syntaxerHelper.eqSyntaxer,
    priority: 3,
    checker: { mandatory: ['string', null] }
};
exports.eqDoubleSign = equalDoubleSignLexeme;
const notEqualLexeme = {
    regexp: 'not_eq(\\s|\\(|"|$)',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('not_eq', 6),
    syntaxer: syntaxerHelper.notEqualSyntaxer,
    priority: 3,
    checker: { mandatory: ['string', null] }
};
exports.not_eq = notEqualLexeme;
const notEqualExclamationLexeme = {
    regexp: '!=',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('not_eq', 2),
    syntaxer: syntaxerHelper.notEqualSyntaxer,
    priority: 3,
    checker: { mandatory: ['string', null] }
};
exports.notEqExclamation = notEqualExclamationLexeme;
const containsLexeme = {
    regexp: 'contains(\\s|\\(|"|$)',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('contains', 8),
    syntaxer: syntaxerHelper.containsSyntaxer,
    priority: 3,
    checker: { mandatory: ['string', null] }
};
exports.contains = containsLexeme;
const notLexeme = {
    regexp: 'not(\\s|\\(|"|$)',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('not', 3),
    syntaxer: syntaxerHelper.notSyntaxer,
    priority: 1,
    checker: { mandatory: ['startBlock', 'string', 'in', null] }
};
exports.not = notLexeme;
const commaLexeme = {
    regexp: ',(\\s|"|$)',
    escaped: true,
    lexer: lexerHelper.generateCutLexer('comma', 1),
    syntaxer: syntaxerHelper.commaSyntaxer,
    priority: 0,
    postFunction: postHelper.commaPostTreatment,
    checker: { mandatory: ['string', null] }
};
exports.comma = commaLexeme;
const inLexeme = {
    regexp: 'in(\\s|\\[|$)',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('in', 2),
    syntaxer: syntaxerHelper.inSyntaxer,
    priority: 1,
    checker: { mandatory: ['startArray', null] }
};
exports.in = inLexeme;
const notInLexeme = {
    regexp: 'not_in(\\s|\\[|$)',
    escaped: true,
    modifiers: 'i',
    lexer: lexerHelper.generateCutLexer('not_in', 6),
    syntaxer: syntaxerHelper.notInSyntaxer,
    priority: 1,
    checker: { mandatory: ['startArray', null] }
};
exports.not_in = notInLexeme;
const startBlockLexeme = {
    regexp: '\\(',
    escaped: true,
    lexer: lexerHelper.generateCutLexer('startBlock', 1),
    syntaxer: syntaxerHelper.blockSyntaxer,
    priority: 0,
    postFunction: postHelper.blockPostTreatment,
    checker: { negative: ['endBlock', null] }
};
exports.startBlock = startBlockLexeme;
const endBlockLexeme = {
    regexp: '\\)',
    escaped: true,
    lexer: lexerHelper.generateCutLexer('endBlock', 1),
    checker: { negative: ['attr'] }
};
exports.endBlock = endBlockLexeme;
const startArrayLexeme = {
    regexp: '\\[',
    escaped: true,
    lexer: lexerHelper.generateCutLexer('startArray', 1),
    syntaxer: syntaxerHelper.arraySyntaxer,
    priority: 0,
    postFunction: postHelper.blockPostTreatment,
    checker: { mandatory: ['string', null] }
};
exports.startArray = startArrayLexeme;
const endArrayLexeme = {
    regexp: '\\]',
    escaped: true,
    lexer: lexerHelper.generateCutLexer('endArray', 1),
};
exports.endArray = endArrayLexeme;
const stringLexeme = {
    regexp: '".*',
    lexer: lexerHelper.stringLexer([endBlockLexeme, endArrayLexeme, commaLexeme]),
    syntaxer: syntaxerHelper.stringSyntaxer,
    checker: { negative: ['string', 'startBlock', 'startArray', 'in', 'not_in', 'eq', 'not_eq', 'not', 'attr', null] },
    priority: 0
};
exports.string = stringLexeme;
const attrLexeme = {
    regexp: '.*',
    lexer: lexerHelper.attrLexer([equalLexeme, equalDoubleSignLexeme, notEqualLexeme, notEqualExclamationLexeme, inLexeme, notInLexeme]),
    syntaxer: syntaxerHelper.attrSyntaxer,
    checker: { negative: ['string', 'startBlock', 'startArray', null] },
    priority: 0
};
exports.attr = attrLexeme;
