"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const got_1 = require("got");
const platform_node_1 = require("@pusher/platform-node");
const utils_1 = require("./utils");
const package_json_1 = __importDefault(require("../package.json"));
const TOKEN_EXPIRY_LEEWAY = 30;
class Chatkit {
    constructor(options) {
        const { instanceLocator, key, port, host, client } = options;
        const sdkInfo = new platform_node_1.SDKInfo({
            productName: "chatkit",
            version: package_json_1.default.version,
        });
        const instanceOptions = {
            locator: instanceLocator,
            key,
            port,
            host,
            client,
            sdkInfo,
        };
        const serverInstanceOptions = (version) => (Object.assign({}, instanceOptions, { serviceName: "chatkit", serviceVersion: version }));
        const authorizerInstanceOptions = Object.assign({}, instanceOptions, { serviceName: "chatkit_authorizer", serviceVersion: "v2" });
        const cursorsInstanceOptions = Object.assign({}, instanceOptions, { serviceName: "chatkit_cursors", serviceVersion: "v2" });
        this.instanceLocator = instanceLocator;
        this.serverInstanceV2 = new platform_node_1.Instance(serverInstanceOptions("v2"));
        this.serverInstanceV3 = new platform_node_1.Instance(serverInstanceOptions("v3"));
        this.authorizerInstance = new platform_node_1.Instance(authorizerInstanceOptions);
        this.cursorsInstance = new platform_node_1.Instance(cursorsInstanceOptions);
    }
    // Token generation
    authenticate(options) {
        const { userId, authPayload } = options;
        return this.serverInstanceV3.authenticate(authPayload || { grant_type: "client_credentials" }, { userId });
    }
    // Used internally - not designed to be used externally
    generateAccessToken(options) {
        return this.serverInstanceV3.generateAccessToken(options);
    }
    // User interactions
    createUser(options) {
        const { id, name } = options;
        return this.serverInstanceV3
            .request({
            method: "POST",
            path: `/users`,
            headers: {
                "Content-Type": "application/json",
            },
            body: {
                id,
                name,
                avatar_url: options.avatarURL,
                custom_data: options.customData,
            },
            jwt: this.getServerToken(),
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    createUsers(options) {
        const users = options.users.map(user => {
            const { id, name } = user;
            return {
                id,
                name,
                avatar_url: user.avatarURL,
                custom_data: user.customData,
            };
        });
        return this.serverInstanceV3
            .request({
            method: "POST",
            path: `/batch_users`,
            headers: {
                "Content-Type": "application/json",
            },
            body: {
                users,
            },
            jwt: this.getServerToken(),
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    updateUser(options) {
        const jwt = this.generateAccessToken({
            su: true,
            userId: options.id,
        });
        let updatePayload = {};
        if (options.name) {
            updatePayload.name = options.name;
        }
        if (options.avatarURL) {
            updatePayload.avatar_url = options.avatarURL;
        }
        if (options.customData) {
            updatePayload.custom_data = options.customData;
        }
        return this.serverInstanceV3
            .request({
            method: "PUT",
            path: `/users/${options.id}`,
            headers: {
                "Content-Type": "application/json",
            },
            body: updatePayload,
            jwt: jwt.token,
        })
            .then(() => { });
    }
    deleteUser(options) {
        return this.serverInstanceV3
            .request({
            method: "DELETE",
            path: `/users/${options.userId}`,
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    getUser(options) {
        return this.serverInstanceV3
            .request({
            method: "GET",
            path: `/users/${encodeURIComponent(options.id)}`,
            jwt: this.getServerToken(),
        })
            .then(({ body }) => JSON.parse(body));
    }
    getUsers(options = {}) {
        return this.serverInstanceV3
            .request({
            method: "GET",
            path: `/users`,
            qs: {
                from_ts: options.fromTimestamp,
                limit: options.limit,
            },
            jwt: this.getServerToken(),
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    getUsersById(options) {
        return this.serverInstanceV3
            .request({
            method: "GET",
            path: `/users_by_ids`,
            qs: {
                id: options.userIds,
            },
            useQuerystring: true,
            jwt: this.getServerToken(),
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    // Room interactions
    getRoom(options) {
        const jwt = this.generateAccessToken({
            su: true,
        });
        return this.serverInstanceV3
            .request({
            method: "GET",
            path: `/rooms/${encodeURIComponent(options.roomId)}`,
            jwt: jwt.token,
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    sendMessage(options) {
        let messagePayload = { text: options.text };
        if (options.attachment) {
            messagePayload.attachment = {
                resource_link: options.attachment.resourceLink,
                type: options.attachment.type,
            };
        }
        return this.serverInstanceV2
            .request({
            method: "POST",
            path: `/rooms/${encodeURIComponent(options.roomId)}/messages`,
            jwt: this.generateAccessToken({
                su: true,
                userId: options.userId,
            }).token,
            body: messagePayload,
        })
            .then(({ body }) => JSON.parse(body));
    }
    sendSimpleMessage(options) {
        return this.sendMultipartMessage({
            roomId: options.roomId,
            userId: options.userId,
            parts: [{ type: "text/plain", content: options.text }],
        });
    }
    sendMultipartMessage(options) {
        if (options.parts.length === 0) {
            return Promise.reject(new TypeError("message must contain at least one part"));
        }
        return Promise.all(options.parts.map((part) => part.file
            ? this.uploadAttachment({
                userId: options.userId,
                roomId: options.roomId,
                part,
            })
            : part))
            .then(parts => this.serverInstanceV3.request({
            method: "POST",
            path: `/rooms/${encodeURIComponent(options.roomId)}/messages`,
            jwt: this.generateAccessToken({
                su: true,
                userId: options.userId,
            }).token,
            body: { parts },
        }))
            .then(({ body }) => JSON.parse(body));
    }
    uploadAttachment({ userId, roomId, part: { type, name, customData, file }, }) {
        return this.serverInstanceV3
            .request({
            method: "POST",
            path: `/rooms/${encodeURIComponent(roomId)}/attachments`,
            jwt: this.generateAccessToken({
                su: true,
                userId,
            }).token,
            body: {
                content_type: type,
                content_length: file.length,
                name,
                custom_data: customData,
            },
        })
            .then(({ body }) => {
            const { attachment_id: attachmentId, upload_url: uploadURL, } = JSON.parse(body);
            return got_1.put(uploadURL, {
                body: file,
                headers: {
                    "content-type": type,
                },
            }).then(() => ({ type, attachment: { id: attachmentId } }));
        });
    }
    deleteMessage(options) {
        return this.serverInstanceV3
            .request({
            method: "DELETE",
            path: `/messages/${options.id}`,
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    getRoomMessages(options) {
        return this.fetchMessages(Object.assign({}, options, { serverInstance: this.serverInstanceV2 }));
    }
    fetchMultipartMessages(options) {
        return this.fetchMessages(Object.assign({}, options, { serverInstance: this.serverInstanceV3 }));
    }
    fetchMessages(options) {
        const jwt = this.generateAccessToken({
            su: true,
        });
        const { initialId } = options, optionsMinusInitialId = __rest(options, ["initialId"]);
        let qs = optionsMinusInitialId;
        if (initialId) {
            qs["initial_id"] = initialId;
        }
        return options.serverInstance
            .request({
            method: "GET",
            path: `/rooms/${encodeURIComponent(options.roomId)}/messages`,
            jwt: jwt.token,
            qs: qs,
        })
            .then(res => JSON.parse(res.body));
    }
    getRooms(options = {}) {
        return this.serverInstanceV3
            .request({
            method: "GET",
            path: `/rooms`,
            jwt: this.getServerToken(),
            qs: {
                from_id: options.fromId,
                include_private: options.includePrivate,
            },
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    getUserRooms(options) {
        const jwt = this.generateAccessToken({
            su: true,
            userId: options.userId,
        });
        return this.serverInstanceV3
            .request({
            method: "GET",
            path: `/users/${options.userId}/rooms`,
            jwt: jwt.token,
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    getUserJoinableRooms(options) {
        const jwt = this.generateAccessToken({
            su: true,
            userId: options.userId,
        });
        return this.serverInstanceV3
            .request({
            method: "GET",
            path: `/users/${options.userId}/rooms`,
            qs: { joinable: true },
            jwt: jwt.token,
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    createRoom(options) {
        const jwt = this.generateAccessToken({
            su: true,
            userId: options.creatorId,
        });
        const { name, isPrivate, userIds, customData } = options;
        let roomPayload = {
            name,
            private: isPrivate || false,
        };
        if (userIds && userIds.length !== 0) {
            roomPayload["user_ids"] = userIds;
        }
        if (customData) {
            roomPayload.custom_data = customData;
        }
        return this.serverInstanceV3
            .request({
            method: "POST",
            path: "/rooms",
            jwt: jwt.token,
            body: roomPayload,
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    updateRoom(options) {
        const body = {};
        if (options.name) {
            body.name = options.name;
        }
        if (options.isPrivate) {
            body.private = options.isPrivate;
        }
        if (options.customData) {
            body.custom_data = options.customData;
        }
        return this.serverInstanceV3
            .request({
            method: "PUT",
            path: `/rooms/${options.id}`,
            jwt: this.getServerToken(),
            body,
        })
            .then(() => { });
    }
    deleteRoom(options) {
        return this.serverInstanceV3
            .request({
            method: "DELETE",
            path: `/rooms/${options.id}`,
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    addUsersToRoom(options) {
        return this.serverInstanceV3
            .request({
            method: "PUT",
            path: `/rooms/${encodeURIComponent(options.roomId)}/users/add`,
            jwt: this.getServerToken(),
            body: { user_ids: options.userIds },
        })
            .then(() => { });
    }
    removeUsersFromRoom(options) {
        return this.serverInstanceV3
            .request({
            method: "PUT",
            path: `/rooms/${encodeURIComponent(options.roomId)}/users/remove`,
            jwt: this.getServerToken(),
            body: { user_ids: options.userIds },
        })
            .then(() => { });
    }
    // Authorizer interactions
    createRoomRole(options) {
        return this.createRole(Object.assign({}, options, { scope: "room" }));
    }
    createGlobalRole(options) {
        return this.createRole(Object.assign({}, options, { scope: "global" }));
    }
    createRole(options) {
        return this.authorizerInstance
            .request({
            method: "POST",
            path: `/roles`,
            headers: {
                "Content-Type": "application/json",
            },
            body: options,
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    deleteGlobalRole(options) {
        return this.authorizerInstance
            .request({
            method: "DELETE",
            path: `/roles/${options.name}/scope/global`,
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    deleteRoomRole(options) {
        return this.authorizerInstance
            .request({
            method: "DELETE",
            path: `/roles/${options.name}/scope/room`,
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    assignGlobalRoleToUser(options) {
        return this.assignRoleToUser(options);
    }
    assignRoomRoleToUser(options) {
        return this.assignRoleToUser(options);
    }
    assignRoleToUser(options) {
        return this.authorizerInstance
            .request({
            method: "PUT",
            path: `/users/${options.userId}/roles`,
            headers: {
                "Content-Type": "application/json",
            },
            body: { name: options.name, room_id: options.roomId },
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    getUserRoles(options) {
        return this.authorizerInstance
            .request({
            method: "GET",
            path: `/users/${options.userId}/roles`,
            jwt: this.getServerToken(),
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    removeGlobalRoleForUser(options) {
        return this.authorizerInstance
            .request({
            method: "DELETE",
            path: `/users/${options.userId}/roles`,
            headers: {
                "Content-Type": "application/json",
            },
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    removeRoomRoleForUser(options) {
        return this.authorizerInstance
            .request({
            method: "DELETE",
            path: `/users/${options.userId}/roles`,
            headers: {
                "Content-Type": "application/json",
            },
            qs: { room_id: options.roomId },
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    getPermissionsForGlobalRole(options) {
        return this.authorizerInstance
            .request({
            method: "GET",
            path: `/roles/${options.name}/scope/global/permissions`,
            jwt: this.getServerToken(),
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    getPermissionsForRoomRole(options) {
        return this.authorizerInstance
            .request({
            method: "GET",
            path: `/roles/${options.name}/scope/room/permissions`,
            jwt: this.getServerToken(),
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    updatePermissionsForGlobalRole(options) {
        return this.updatePermissionsForRole(options.name, "global", options.permissionsToAdd || [], options.permissionsToRemove || []);
    }
    updatePermissionsForRoomRole(options) {
        return this.updatePermissionsForRole(options.name, "room", options.permissionsToAdd || [], options.permissionsToRemove || []);
    }
    getRoles() {
        return this.authorizerInstance
            .request({
            method: "GET",
            path: `/roles`,
            jwt: this.getServerToken(),
        })
            .then(res => {
            return JSON.parse(res.body);
        });
    }
    // Cursors
    setReadCursor(options) {
        return this.cursorsInstance
            .request({
            method: "PUT",
            path: `/cursors/0/rooms/${encodeURIComponent(options.roomId)}/users/${encodeURIComponent(options.userId)}`,
            body: { position: options.position },
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    getReadCursor(options) {
        return this.cursorsInstance
            .request({
            method: "GET",
            path: `/cursors/0/rooms/${encodeURIComponent(options.roomId)}/users/${encodeURIComponent(options.userId)}`,
            jwt: this.getServerToken(),
        })
            .then(({ body }) => JSON.parse(body));
    }
    getReadCursorsForUser(options) {
        return this.cursorsInstance
            .request({
            method: "GET",
            path: `/cursors/0/users/${encodeURIComponent(options.userId)}`,
            jwt: this.getServerToken(),
        })
            .then(({ body }) => JSON.parse(body));
    }
    getReadCursorsForRoom(options) {
        return this.cursorsInstance
            .request({
            method: "GET",
            path: `/cursors/0/rooms/${encodeURIComponent(options.roomId)}`,
            jwt: this.getServerToken(),
        })
            .then(({ body }) => JSON.parse(body));
    }
    // General requests
    apiRequest(options) {
        options.jwt = options.jwt || this.getServerToken();
        return this.serverInstanceV3.request(options);
    }
    authorizerRequest(options) {
        options.jwt = options.jwt || this.getServerToken();
        return this.authorizerInstance.request(options);
    }
    cursorsRequest(options) {
        options.jwt = options.jwt || this.getServerToken();
        return this.cursorsInstance.request(options);
    }
    updatePermissionsForRole(name, scope, permissionsToadd = [], permissionsToRemove = []) {
        if (permissionsToadd.length === 0 && permissionsToRemove.length === 0) {
            throw new Error(`Either permissionsToAdd or permissionsToRemove is required`);
        }
        let body = {};
        if (permissionsToadd.length > 0) {
            body["add_permissions"] = permissionsToadd;
        }
        if (permissionsToRemove.length > 0) {
            body["remove_permissions"] = permissionsToRemove;
        }
        return this.authorizerInstance
            .request({
            method: "PUT",
            path: `/roles/${name}/scope/${scope}/permissions`,
            headers: {
                "Content-Type": "application/json",
            },
            body: body,
            jwt: this.getServerToken(),
        })
            .then(() => { });
    }
    /**
     * This method manages the token for http library and pusher platform
     * communication
     */
    getServerToken() {
        if (this.tokenWithExpiry &&
            this.tokenWithExpiry.expiresAt > utils_1.getCurrentTimeInSeconds()) {
            return this.tokenWithExpiry.token;
        }
        // Otherwise generate new token and its expiration time
        const tokenWithExpiresIn = this.serverInstanceV3.generateAccessToken({
            su: true,
        });
        this.tokenWithExpiry = {
            token: tokenWithExpiresIn.token,
            expiresAt: utils_1.getCurrentTimeInSeconds() +
                tokenWithExpiresIn.expires_in -
                TOKEN_EXPIRY_LEEWAY,
        };
        return this.tokenWithExpiry.token;
    }
}
exports.default = Chatkit;
//# sourceMappingURL=chatkit.js.map