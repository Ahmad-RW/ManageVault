"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const user_1 = require("../user");
const userdescriptors_1 = require("./userdescriptors");
/**
 * @classdesc Container for known users
 * @fires Users#userUpdated
 */
class Users extends events_1.EventEmitter {
    constructor(services) {
        super();
        this.services = services;
        this.fifoStack = [];
        this.fifoStackMaxLength = 100;
        this.myself = new user_1.User(null, null, this.services);
        this.myself.on('updated', (args) => this.emit('userUpdated', args));
        this.myself.on('userSubscribed', () => this.emit('userSubscribed', this.myself));
        this.myself.on('userUnsubscribed', () => {
            this.emit('userUnsubscribed', this.myself);
            this.myself._ensureFetched();
        });
        this.services = services;
        this.subscribedUsers = new Map();
        this.userDescriptorsPromise =
            this.services.session.getSessionLinks()
                .then((links) => {
                this.userDescriptors = new userdescriptors_1.UserDescriptors({
                    users: this,
                    network: this.services.network
                }, links.usersUrl);
                return this.userDescriptors;
            });
        this.services.session.getMaxUserInfosToSubscribe()
            .then(maxUserInfosToSubscribe => {
            this.fifoStackMaxLength = maxUserInfosToSubscribe;
        });
        this.services.session.getUsersData()
            .then(data => {
            this.myself.identity = data.identity;
            this.myself.entityName = data.user;
            return this.myself._ensureFetched();
        });
    }
    handleUnsubscribeUser(user) {
        if (this.subscribedUsers.has(user.identity)) {
            this.subscribedUsers.delete(user.identity);
        }
        let foundItemIndex = -1;
        let foundItem = this.fifoStack.find((item, index) => {
            if (item == user.identity) {
                foundItemIndex = index;
                return true;
            }
            return false;
        });
        if (foundItem) {
            this.fifoStack.splice(foundItemIndex, 1);
        }
        this.emit('userUnsubscribed', user);
    }
    handleSubscribeUser(user) {
        if (this.subscribedUsers.has(user.identity)) {
            return;
        }
        if (this.fifoStack.length >= this.fifoStackMaxLength) {
            this.subscribedUsers.get(this.fifoStack.shift()).unsubscribe();
        }
        this.fifoStack.push(user.identity);
        this.subscribedUsers.set(user.identity, user);
        this.emit('userSubscribed', user);
    }
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity, entityName = null) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.services.session.getUsersData();
            yield this.myself._ensureFetched();
            if (identity == this.myself.identity) {
                return this.myself;
            }
            let user = this.subscribedUsers.get(identity);
            if (!user) {
                if (!entityName) {
                    let userDescriptor = yield this.getUserDescriptor(identity);
                    entityName = userDescriptor._getDescriptor().sync_unique_name;
                }
                user = new user_1.User(identity, entityName, this.services);
                user.on('updated', (args) => this.emit('userUpdated', args));
                user.on('userSubscribed', () => this.handleSubscribeUser(user));
                user.on('userUnsubscribed', () => this.handleUnsubscribeUser(user));
                yield user._ensureFetched();
            }
            return user;
        });
    }
    /**
     * @returns {Promise<UserDescriptor>} User descriptor
     */
    getUserDescriptor(identity) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.userDescriptorsPromise;
            return this.userDescriptors.getUserDescriptor(identity);
        });
    }
    /**
     * @returns {Promise<Paginator<UserDescriptor>>} Users descriptors page for given channel sid
     */
    getChannelUserDescriptors(channelSid) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.userDescriptorsPromise;
            return this.userDescriptors.getChannelUserDescriptors(channelSid);
        });
    }
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */
    getSubscribedUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.services.session.getUsersData();
            yield this.myself._ensureFetched();
            let users = [this.myself];
            this.subscribedUsers.forEach((user) => users.push(user));
            return users;
        });
    }
}
exports.Users = Users;
