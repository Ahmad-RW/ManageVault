"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const member_1 = require("../member");
const logger_1 = require("../logger");
const log = logger_1.Logger.scope('Members');
/**
 * @classdesc Represents the collection of members for the channel
 * @fires Members#memberJoined
 * @fires Members#memberLeft
 * @fires Members#memberUpdated
 */
class Members extends events_1.EventEmitter {
    constructor(channel, services, members) {
        super();
        this.services = services;
        this.channel = channel;
        this.members = members;
    }
    unsubscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.rosterEntityPromise) {
                let entity = yield this.rosterEntityPromise;
                entity.close();
                this.rosterEntityPromise = null;
            }
        });
    }
    subscribe(rosterObjectName) {
        return this.rosterEntityPromise = this.rosterEntityPromise
            || this.services.syncClient.map({ id: rosterObjectName, mode: 'open_existing' })
                .then(rosterMap => {
                rosterMap.on('itemAdded', args => {
                    this.upsertMember(args.item.key, args.item.value)
                        .then(member => {
                        this.emit('memberJoined', member);
                    });
                });
                rosterMap.on('itemRemoved', args => {
                    let memberSid = args.key;
                    if (!this.members.has(memberSid)) {
                        return;
                    }
                    let leftMember = this.members.get(memberSid);
                    this.members.delete(memberSid);
                    this.emit('memberLeft', leftMember);
                });
                rosterMap.on('itemUpdated', args => {
                    this.upsertMember(args.item.key, args.item.value);
                });
                let membersPromises = [];
                return rosterMap.forEach(item => {
                    membersPromises.push(this.upsertMember(item.key, item.value));
                })
                    .then(() => Promise.all(membersPromises))
                    .then(() => rosterMap);
            })
                .catch(err => {
                this.rosterEntityPromise = null;
                if (this.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get roster object for channel', this.channel.sid, err);
                }
                log.debug('ERROR: Failed to get roster object for channel', this.channel.sid, err);
                throw err;
            });
    }
    upsertMember(memberSid, data) {
        return __awaiter(this, void 0, void 0, function* () {
            let member = this.members.get(memberSid);
            if (member) {
                return member._update(data);
            }
            member = new member_1.Member(this.services, this.channel, data, memberSid);
            this.members.set(memberSid, member);
            member.on('updated', (args) => this.emit('memberUpdated', args));
            return member;
        });
    }
    /**
     * @returns {Promise<Array<Member>>} returns list of members {@see Member}
     */
    getMembers() {
        return this.rosterEntityPromise.then(() => {
            let members = [];
            this.members.forEach((member) => members.push(member));
            return members;
        });
    }
    /**
     * Add user to the channel
     * @returns {Promise<void|SessionError>}
     */
    add(username) {
        return this.services.session.addCommand('addMemberV2', {
            channelSid: this.channel.sid,
            username: username
        });
    }
    /**
     * Invites user to the channel
     * User can choose either to join or not
     * @returns {Promise<|SessionError>}
     */
    invite(username) {
        return this.services.session.addCommand('inviteMember', {
            channelSid: this.channel.sid,
            username: username
        });
    }
    /**
     * Remove user from channel
     * @returns {Promise<|SessionError>}
     */
    remove(username) {
        return this.services.session.addCommand('removeMember', {
            channelSid: this.channel.sid,
            username: username
        });
    }
}
exports.Members = Members;
/**
 * Fired when member joined channel
 * @event Members#memberJoined
 * @type {Member}
 */
/**
 * Fired when member left channel
 * @event Members#memberLeft
 * @type {Member}
 */
/**
 * Fired when member updated
 * @event Members#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
