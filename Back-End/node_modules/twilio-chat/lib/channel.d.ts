/// <reference types="node" />
import { EventEmitter } from 'events';
import { Member } from './member';
import { Message } from './message';
import { UserDescriptor } from './userdescriptor';
import { Users } from './data/users';
import { Paginator } from './interfaces/paginator';
import { Channels } from './data/channels';
import { McsClient } from 'twilio-mcs-client';
import * as FormData from 'isomorphic-form-data';
import { SyncClient } from 'twilio-sync';
import { Session } from './session';
import { ConsumptionHorizon } from './services/consumptionhorizon';
import { TypingIndicator } from './services/typingindicator';
import { Network } from './services/network';
declare function filterStatus(status: any): any;
export interface ChannelServices {
    session: Session;
    users: Users;
    typingIndicator: TypingIndicator;
    consumptionHorizon: ConsumptionHorizon;
    network: Network;
    mcsClient: McsClient;
    syncClient: SyncClient;
}
interface ChannelDescriptor {
    name: string;
    channel: string;
    entityName: string;
    uniqueName: string;
    attributes: Object;
    createdBy: string;
    friendlyName: string;
    lastConsumedMessageIndex: number;
    dateCreated: any;
    dateUpdated: any;
    type: Channel.Type;
    notificationLevel?: Channel.NotificationLevel;
}
declare namespace Channel {
    type UpdateReason = 'attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' | 'friendlyName' | 'lastConsumedMessageIndex' | 'status' | 'uniqueName' | 'lastMessage' | 'notificationLevel';
    type Status = 'unknown' | 'known' | 'invited' | 'joined';
    type Type = 'public' | 'private';
    type NotificationLevel = 'default' | 'muted';
    interface UpdatedEventArgs {
        channel: Channel;
        updateReasons: Channel.UpdateReason[];
    }
    interface SendMediaOptions {
        contentType: string;
        media: string | Buffer;
    }
    interface LastMessage {
        index?: number;
        timestamp?: Date;
    }
}
/**
 * @classdesc A Channel represents a remote channel of communication between multiple Programmable Chat Clients
 * @property {Object} attributes - The Channel's custom attributes
 * @property {String} createdBy - The identity of the User that created this Channel
 * @property {Date} dateCreated - The Date this Channel was created
 * @property {Date} dateUpdated - The Date this Channel was last updated
 * @property {String} friendlyName - The Channel's name
 * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)
 * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel
 * @property {Channel#LastMessage} lastMessage - Last Message sent to this Channel
 * @property {Channel#NotificationLevel} notificationLevel - User Notification level for this Channel
 * @property {String} sid - The Channel's unique system identifier
 * @property {Channel#Status} status - The Channel's status
 * @property {Channel#Type} type - The Channel's type
 * @property {String} uniqueName - The Channel's unique name (tag)
 * @fires Channel#memberJoined
 * @fires Channel#memberLeft
 * @fires Channel#memberUpdated
 * @fires Channel#messageAdded
 * @fires Channel#messageRemoved
 * @fires Channel#messageUpdated
 * @fires Channel#typingEnded
 * @fires Channel#typingStarted
 * @fires Channel#updated
 */
declare class Channel extends EventEmitter {
    readonly sid: string;
    private services;
    private state;
    private statusSource;
    private entityPromise;
    private entityName;
    private entity;
    private messagesEntity;
    private membersEntity;
    private members;
    /**
     * These options can be passed to {@link Channel#sendMessage}.
     * @typedef {Object} Channel#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * The update reason for <code>updated</code> event emitted on Channel
     * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |
      'friendlyName' | 'lastConsumedMessageIndex' | 'status' | 'uniqueName' | 'lastMessage' |
      'notificationLevel' )} Channel#UpdateReason
     */
    /**
     * The status of the Channel, relative to the Client: whether the Channel
     * is <code>known</code> to local Client, Client is <code>invited</code> to or
     * is <code>joined</code> to this Channel
     * @typedef {('unknown' | 'known' | 'invited' | 'joined')} Channel#Status
     */
    /**
     * The type of Channel (<code>public</code> or <code>private</code>).
     * @typedef {('public' | 'private')} Channel#Type
     */
    /**
     * The User's Notification level for Channel, determines whether the currently logged-in User will receive
     * pushes for events in this Channel. Can be either <code>muted</code> or <code>default</code>,
     * where <code>default</code> defers to global Service push configuration.
     * @typedef {('default' | 'muted')} Channel#NotificationLevel
     */
    constructor(services: ChannelServices, descriptor: ChannelDescriptor, sid: string);
    readonly status: Channel.Status;
    readonly type: Channel.Type;
    readonly uniqueName: string;
    readonly isPrivate: boolean;
    readonly friendlyName: string;
    readonly dateUpdated: any;
    readonly dateCreated: any;
    readonly createdBy: string;
    readonly attributes: Object;
    readonly lastConsumedMessageIndex: number;
    readonly lastMessage: Channel.LastMessage;
    readonly notificationLevel: Channel.NotificationLevel;
    /**
     * The Channel's last message's information.
     * @typedef {Object} Channel#LastMessage
     * @property {Number} index - Message's index
     * @property {Date} timestamp - Message's creation timestamp
     */
    /**
     * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.
     * This or _subscribeStreams will need to be called before any events on Channel will fire.
     * @returns {Promise}
     * @private
     */
    _subscribe(): Promise<any>;
    /**
     * Load the attributes of this Channel and instantiate its Members and Messages.
     * This or _subscribe will need to be called before any events on Channel will fire.
     * This will need to be called before any events on Members or Messages will fire
     * @returns {Promise}
     * @private
     */
    _subscribeStreams(): Promise<void>;
    /**
     * Stop listening for and firing events on this Channel.
     * @returns {Promise}
     * @private
     */
    _unsubscribe(): Promise<[any, any]>;
    /**
     * Set channel status
     * @private
     */
    _setStatus(status: Channel.Status, source: Channels.DataSource): void;
    /**
     * If channel's status update source
     * @private
     * @return {Channels.DataSource}
     */
    _statusSource(): Channels.DataSource;
    private static preprocessUpdate;
    /**
     * Updates local channel object with new values
     * @private
     */
    _update(update: any): void;
    /**
     * @private
     */
    private _onMessageAdded;
    /**
     * Add a participant to the Channel by its Identity.
     * @param {String} identity - Identity of the Client to add
     * @returns {Promise<void|Error|SessionError>}
     */
    add(identity: string): Promise<any>;
    /**
     * Advance last consumed Channel's Message index to current consumption horizon.
     * Rejects if User is not Member of Channel.
     * Last consumed Message index is updated only if new index value is higher than previous.
     * @param {Number} index - Message index to advance to as last read
     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
     */
    advanceLastConsumedMessageIndex(index: number): Promise<number>;
    /**
     * Decline an invitation to the Channel and unsubscribe from its events.
     * @returns {Promise<Channel|SessionError>}
     */
    decline(): Promise<Channel>;
    /**
     * Delete the Channel and unsubscribe from its events.
     * @returns {Promise<Channel|SessionError>}
     */
    delete(): Promise<Channel>;
    /**
     * Get the custom attributes of this Channel.<br/>
     *
     * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>
     * @returns {Promise<Object>}
     */
    getAttributes(): Promise<Object>;
    /**
     * Returns messages from channel using paginator interface.
     * @param {Number} [pageSize=30] Number of messages to return in single chunk
     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
     * @param {String} [direction=backwards] - Query direction. By default it query backwards
     *                                         from newer to older. 'forward' will query in opposite direction
     * @returns {Promise<Paginator<Message>>} page of messages
     */
    getMessages(pageSize?: number, anchor?: number, direction?: string): Promise<Paginator<Message>>;
    /**
     * Get a list of all Members joined to this Channel.
     * @returns {Promise<Array<Member>>}
     */
    getMembers(): Promise<Array<Member>>;
    /**
     * Get channel members count.
     * @returns {Promise<number|Error>}
     */
    getMembersCount(): Promise<number>;
    /**
     * Get total message count in a channel.
     * @returns {Promise<number|Error>}
     */
    getMessagesCount(): Promise<number>;
    /**
     * Get unconsumed messages count for User if he is Member of this Channel.
     * Rejects if User is not Member of Channel.
     * @returns {Promise<number|Error>}
     */
    getUnconsumedMessagesCount(): Promise<number>;
    /**
     * Invite a user to the Channel by their Identity.
     * @param {String} identity - Identity of the user to invite
     * @returns {Promise<void|Error|SessionError>}
     */
    invite(identity: string): Promise<void>;
    /**
     * Join the Channel and subscribe to its events.
     * @returns {Promise<Channel|SessionError>}
     */
    join(): Promise<Channel>;
    /**
     * Leave the Channel.
     * @returns {Promise<Channel|SessionError>}
     */
    leave(): Promise<Channel>;
    /**
     * Remove a Member from the Channel.
     * @param {String} member - identity of member to remove
     * @returns {Promise<void|Error|SessionError>}
     */
    removeMember(member: any): Promise<void>;
    /**
     * Send a Message in the Channel.
     * @param {String | FormData | Channel#SendMediaOptions} message - The message body for text message,
     * FormData or MediaOptions for media content
     * @param {Object} messageAttributes - attributes for the message
     * @returns {Promise<number|Error|SessionError>} new Message's index in the Channel's messages list
     */
    sendMessage(message: string | FormData | Channel.SendMediaOptions, messageAttributes?: Object): Promise<number>;
    /**
     * Set last consumed Channel's Message index to last known Message's index in this Channel.
     * @returns {Promise<number|SessionError>} resulting unread messages count in the channel
     */
    setAllMessagesConsumed(): Promise<number>;
    /**
     * Set all messages in the channel unread.
     * @returns {Promise<number|SessionError>} resulting unread messages count in the channel
     */
    setNoMessagesConsumed(): Promise<number>;
    /**
     * Set User Notification level for this channel.
     * @param {Channel#NotificationLevel} notificationLevel - The new user notification level
     * @returns {Promise<void|Error|SessionError>}
     */
    setUserNotificationLevel(notificationLevel: Channel.NotificationLevel): Promise<void>;
    /**
     * Send a notification to the server indicating that this Client is currently typing in this Channel.
     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
     * @returns {Promise<void|SessionError>}
     */
    typing(): any;
    /**
     * Update the Channel's attributes.
     * @param {Object} attributes - The new attributes object
     * @returns {Promise<Channel|Error|SessionError>}
     */
    updateAttributes(attributes: Object): Promise<this>;
    /**
     * Update the Channel's friendlyName.
     * @param {String} name - The new Channel friendlyName
     * @returns {Promise<Channel|SessionError>}
     */
    updateFriendlyName(name: string): Promise<this>;
    /**
     * Set last consumed Channel's Message index to current consumption horizon.
     * @param {Number|null} index - Message index to set as last read.
     * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}
     * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
     */
    updateLastConsumedMessageIndex(index: number): Promise<number>;
    /**
     * Update the Channel's unique name.
     * @param {String} uniqueName - The new Channel uniqueName
     * @returns {Promise<Channel|SessionError>}
     */
    updateUniqueName(uniqueName: string): Promise<Channel>;
    /**
     * Gets User Descriptors for this channel.
     * @returns {Promise<Paginator<UserDescriptor>>}
     */
    getUserDescriptors(): Promise<Paginator<UserDescriptor>>;
}
export { ChannelDescriptor, Channel, filterStatus };
/**
 * Fired when a Member has joined the Channel.
 * @event Channel#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Channel#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Channel#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Channel.
 * @event Channel#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Channel#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Channel#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when a Member has stopped typing.
 * @event Channel#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Channel#typingStarted
 * @type {Member}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create | creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Channel#updated
 * @type {Object}
 * @property {Channel} channel - Updated Channel
 * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons
 */
