"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const logger_1 = require("../logger");
const notificationtypes_1 = require("../interfaces/notificationtypes");
const log = logger_1.Logger.scope('TypingIndicator');
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */
class TypingIndicator {
    constructor(config, services, getChannel) {
        this.config = config;
        this.services = services;
        this.getChannel = getChannel;
        this.serviceTypingTimeout = null;
        this.sentUpdates = new Map();
    }
    get typingTimeout() {
        return this.config.typingIndicatorTimeoutOverride
            || this.serviceTypingTimeout
            || this.config.typingIndicatorTimeoutDefault;
    }
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */
    initialize() {
        this.services.notificationClient.subscribe(notificationtypes_1.NotificationTypes.TYPING_INDICATOR, 'twilsock');
        this.services.notificationClient.on('message', (type, message) => {
            if (type === notificationtypes_1.NotificationTypes.TYPING_INDICATOR) {
                this.handleRemoteTyping(message);
            }
        });
    }
    /**
     * Remote members typing events handler
     * @private
     */
    handleRemoteTyping(message) {
        log.trace('Got new typing indicator ', message);
        this.getChannel(message.channel_sid)
            .then(channel => {
            if (channel) {
                channel.members.forEach(member => {
                    if (member.identity === message.identity) {
                        member._startTyping(this.typingTimeout);
                    }
                });
            }
        })
            .catch(err => {
            log.error(err);
            throw err;
        });
    }
    /**
     * Send typing event for the given channel sid
     * @param {String} channelSid
     */
    send(channelSid) {
        const lastUpdate = this.sentUpdates.get(channelSid);
        if (lastUpdate && lastUpdate > (Date.now() - this.typingTimeout)) {
            return Promise.resolve();
        }
        this.sentUpdates.set(channelSid, Date.now());
        return this._send(channelSid);
    }
    _send(channelSid) {
        log.trace('Sending typing indicator');
        const url = this.config.typingIndicatorUri;
        const headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        };
        const body = 'ChannelSid=' + channelSid;
        return this.services.transport.post(url, headers, body)
            .then(response => {
            if (response.body.hasOwnProperty('typing_timeout')) {
                this.serviceTypingTimeout = response.body.typing_timeout * 1000;
            }
        }).catch(err => {
            log.error('Failed to send typing indicator:', err);
            throw err;
        });
    }
}
exports.TypingIndicator = TypingIndicator;
