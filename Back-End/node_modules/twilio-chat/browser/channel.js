"use strict";

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _isInteger = require("babel-runtime/core-js/number/is-integer");

var _isInteger2 = _interopRequireDefault(_isInteger);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = _promise2.default))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var logger_1 = require("./logger");
var members_1 = require("./data/members");
var member_1 = require("./member");
var messages_1 = require("./data/messages");
var util_1 = require("./util");
var log = logger_1.Logger.scope('Channel');
var fieldMappings = {
    lastMessage: 'lastMessage',
    attributes: 'attributes',
    createdBy: 'createdBy',
    dateCreated: 'dateCreated',
    dateUpdated: 'dateUpdated',
    friendlyName: 'friendlyName',
    lastConsumedMessageIndex: 'lastConsumedMessageIndex',
    name: 'friendlyName',
    notificationLevel: 'notificationLevel',
    sid: 'sid',
    status: 'status',
    type: 'type',
    uniqueName: 'uniqueName'
};
function parseTime(timeString) {
    try {
        return new Date(timeString);
    } catch (e) {
        return null;
    }
}
function filterStatus(status) {
    switch (status) {
        case 'notParticipating':
            return 'known';
        default:
            return status;
    }
}
exports.filterStatus = filterStatus;
/**
 * @classdesc A Channel represents a remote channel of communication between multiple Programmable Chat Clients
 * @property {Object} attributes - The Channel's custom attributes
 * @property {String} createdBy - The identity of the User that created this Channel
 * @property {Date} dateCreated - The Date this Channel was created
 * @property {Date} dateUpdated - The Date this Channel was last updated
 * @property {String} friendlyName - The Channel's name
 * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)
 * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel
 * @property {Channel#LastMessage} lastMessage - Last Message sent to this Channel
 * @property {Channel#NotificationLevel} notificationLevel - User Notification level for this Channel
 * @property {String} sid - The Channel's unique system identifier
 * @property {Channel#Status} status - The Channel's status
 * @property {Channel#Type} type - The Channel's type
 * @property {String} uniqueName - The Channel's unique name (tag)
 * @fires Channel#memberJoined
 * @fires Channel#memberLeft
 * @fires Channel#memberUpdated
 * @fires Channel#messageAdded
 * @fires Channel#messageRemoved
 * @fires Channel#messageUpdated
 * @fires Channel#typingEnded
 * @fires Channel#typingStarted
 * @fires Channel#updated
 */

var Channel = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Channel, _events_1$EventEmitte);

    /**
     * These options can be passed to {@link Channel#sendMessage}.
     * @typedef {Object} Channel#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * The update reason for <code>updated</code> event emitted on Channel
     * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |
      'friendlyName' | 'lastConsumedMessageIndex' | 'status' | 'uniqueName' | 'lastMessage' |
      'notificationLevel' )} Channel#UpdateReason
     */
    /**
     * The status of the Channel, relative to the Client: whether the Channel
     * is <code>known</code> to local Client, Client is <code>invited</code> to or
     * is <code>joined</code> to this Channel
     * @typedef {('unknown' | 'known' | 'invited' | 'joined')} Channel#Status
     */
    /**
     * The type of Channel (<code>public</code> or <code>private</code>).
     * @typedef {('public' | 'private')} Channel#Type
     */
    /**
     * The User's Notification level for Channel, determines whether the currently logged-in User will receive
     * pushes for events in this Channel. Can be either <code>muted</code> or <code>default</code>,
     * where <code>default</code> defers to global Service push configuration.
     * @typedef {('default' | 'muted')} Channel#NotificationLevel
     */
    function Channel(services, descriptor, sid) {
        (0, _classCallCheck3.default)(this, Channel);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Channel.__proto__ || (0, _getPrototypeOf2.default)(Channel)).call(this));

        var attributes = descriptor.attributes || {};
        var createdBy = descriptor.createdBy;
        var dateCreated = parseTime(descriptor.dateCreated);
        var dateUpdated = parseTime(descriptor.dateUpdated);
        var friendlyName = descriptor.name || descriptor.friendlyName || null;
        var lastConsumedMessageIndex = (0, _isInteger2.default)(descriptor.lastConsumedMessageIndex) ? descriptor.lastConsumedMessageIndex : null;
        var uniqueName = descriptor.uniqueName || null;
        try {
            (0, _stringify2.default)(attributes);
        } catch (e) {
            throw new Error('Attributes must be a valid JSON object.');
        }
        _this.services = services;
        _this.sid = sid;
        _this.entityName = descriptor.channel;
        _this.state = {
            uniqueName: uniqueName,
            status: 'known',
            type: descriptor.type,
            attributes: attributes,
            createdBy: createdBy,
            dateCreated: dateCreated,
            dateUpdated: dateUpdated,
            friendlyName: friendlyName,
            lastConsumedMessageIndex: lastConsumedMessageIndex
        };
        if (descriptor.notificationLevel) {
            _this.state.notificationLevel = descriptor.notificationLevel;
        }
        _this.members = new _map2.default();
        _this.membersEntity = new members_1.Members(_this, _this.services, _this.members);
        _this.membersEntity.on('memberJoined', _this.emit.bind(_this, 'memberJoined'));
        _this.membersEntity.on('memberLeft', _this.emit.bind(_this, 'memberLeft'));
        _this.membersEntity.on('memberUpdated', function (args) {
            return _this.emit('memberUpdated', args);
        });
        _this.messagesEntity = new messages_1.Messages(_this, services);
        _this.messagesEntity.on('messageAdded', function (message) {
            return _this._onMessageAdded(message);
        });
        _this.messagesEntity.on('messageUpdated', function (args) {
            return _this.emit('messageUpdated', args);
        });
        _this.messagesEntity.on('messageRemoved', _this.emit.bind(_this, 'messageRemoved'));
        return _this;
    }

    (0, _createClass3.default)(Channel, [{
        key: "_subscribe",

        /**
         * The Channel's last message's information.
         * @typedef {Object} Channel#LastMessage
         * @property {Number} index - Message's index
         * @property {Date} timestamp - Message's creation timestamp
         */
        /**
         * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.
         * This or _subscribeStreams will need to be called before any events on Channel will fire.
         * @returns {Promise}
         * @private
         */
        value: function _subscribe() {
            var _this2 = this;

            if (this.entityPromise) {
                return this.entityPromise;
            }
            return this.entityPromise = this.entityPromise || this.services.syncClient.document({ id: this.entityName, mode: 'open_existing' }).then(function (entity) {
                _this2.entity = entity;
                _this2.entity.on('updated', function (args) {
                    _this2._update(args.value);
                });
                _this2.entity.on('removed', function () {
                    return _this2.emit('removed', _this2);
                });
                _this2._update(_this2.entity.value);
                return entity;
            }).catch(function (err) {
                _this2.entity = null;
                _this2.entityPromise = null;
                if (_this2.services.syncClient.connectionState != 'disconnected') {
                    log.error('Failed to get channel object', err);
                }
                log.debug('ERROR: Failed to get channel object', err);
                throw err;
            });
        }
        /**
         * Load the attributes of this Channel and instantiate its Members and Messages.
         * This or _subscribe will need to be called before any events on Channel will fire.
         * This will need to be called before any events on Members or Messages will fire
         * @returns {Promise}
         * @private
         */

    }, {
        key: "_subscribeStreams",
        value: function _subscribeStreams() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var messagesObjectName, rosterObjectName;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.prev = 0;
                                _context.next = 3;
                                return this._subscribe();

                            case 3:
                                log.trace('_subscribeStreams, this.entity.value=', this.entity.value);
                                messagesObjectName = this.entity.value.messages;
                                rosterObjectName = this.entity.value.roster;
                                _context.next = 8;
                                return _promise2.default.all([this.messagesEntity.subscribe(messagesObjectName), this.membersEntity.subscribe(rosterObjectName)]);

                            case 8:
                                _context.next = 15;
                                break;

                            case 10:
                                _context.prev = 10;
                                _context.t0 = _context["catch"](0);

                                if (this.services.syncClient.connectionState !== 'disconnected') {
                                    log.error('Failed to subscribe on channel objects', this.sid, _context.t0);
                                }
                                log.debug('ERROR: Failed to subscribe on channel objects', this.sid, _context.t0);
                                throw _context.t0;

                            case 15:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[0, 10]]);
            }));
        }
        /**
         * Stop listening for and firing events on this Channel.
         * @returns {Promise}
         * @private
         */

    }, {
        key: "_unsubscribe",
        value: function _unsubscribe() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!(this.isPrivate && this.entity)) {
                                    _context2.next = 5;
                                    break;
                                }

                                _context2.next = 3;
                                return this.entity.close();

                            case 3:
                                this.entity = null;
                                this.entityPromise = null;

                            case 5:
                                return _context2.abrupt("return", _promise2.default.all([this.membersEntity.unsubscribe(), this.messagesEntity.unsubscribe()]));

                            case 6:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));
        }
        /**
         * Set channel status
         * @private
         */

    }, {
        key: "_setStatus",
        value: function _setStatus(status, source) {
            var _this3 = this;

            this.statusSource = source;
            if (this.state.status === status) {
                return;
            }
            this.state.status = status;
            if (status === 'joined') {
                this._subscribeStreams().catch(function (err) {
                    log.debug('ERROR while setting channel status ' + status, err);
                    if (_this3.services.syncClient.connectionState !== 'disconnected') {
                        throw err;
                    }
                });
            } else if (status === 'invited') {
                this._subscribe().catch(function (err) {
                    log.debug('ERROR while setting channel status ' + status, err);
                    if (_this3.services.syncClient.connectionState !== 'disconnected') {
                        throw err;
                    }
                });
            } else if (this.entityPromise) {
                this._unsubscribe().catch(function (err) {
                    log.debug('ERROR while setting channel status ' + status, err);
                    if (_this3.services.syncClient.connectionState !== 'disconnected') {
                        throw err;
                    }
                });
            }
        }
        /**
         * If channel's status update source
         * @private
         * @return {Channels.DataSource}
         */

    }, {
        key: "_statusSource",
        value: function _statusSource() {
            return this.statusSource;
        }
    }, {
        key: "_update",

        /**
         * Updates local channel object with new values
         * @private
         */
        value: function _update(update) {
            log.trace('_update', update);
            var updateReasons = [];
            Channel.preprocessUpdate(update, this.sid);
            for (var key in update) {
                var localKey = fieldMappings[key];
                if (!localKey) {
                    continue;
                }
                if (localKey === fieldMappings.status) {
                    if (update.status && update.status != 'unknown' && this.state.status !== filterStatus(update.status)) {
                        this.state.status = filterStatus(update.status);
                        updateReasons.push(localKey);
                    }
                } else if (localKey === fieldMappings.attributes) {
                    if (!util_1.isDeepEqual(this.state.attributes, update.attributes)) {
                        this.state.attributes = update.attributes;
                        updateReasons.push(localKey);
                    }
                } else if (localKey === fieldMappings.lastConsumedMessageIndex) {
                    if (!(typeof update.lastConsumedMessageIndex === 'undefined') && update.lastConsumedMessageIndex !== this.state.lastConsumedMessageIndex) {
                        this.state.lastConsumedMessageIndex = update.lastConsumedMessageIndex;
                        updateReasons.push(localKey);
                    }
                } else if (localKey === fieldMappings.lastMessage) {
                    var updated = false;
                    if (this.state.lastMessage && !update.lastMessage) {
                        delete this.state.lastMessage;
                        updated = true;
                    } else {
                        if (!this.state.lastMessage) {
                            this.state.lastMessage = {};
                        }
                        if (update.lastMessage && typeof update.lastMessage.index !== 'undefined' && update.lastMessage.index !== this.state.lastMessage.index) {
                            this.state.lastMessage.index = update.lastMessage.index;
                            updated = true;
                        }
                        if (update.lastMessage && update.lastMessage.timestamp && (!this.state.lastMessage.timestamp || this.state.lastMessage.timestamp.getTime() !== update.lastMessage.timestamp.getTime())) {
                            this.state.lastMessage.timestamp = update.lastMessage.timestamp;
                            updated = true;
                        }
                        if (util_1.isDeepEqual(this.state.lastMessage, {})) {
                            delete this.state.lastMessage;
                        }
                    }
                    if (updated) {
                        updateReasons.push(localKey);
                    }
                } else if (update[key] instanceof Date) {
                    if (!this.state[localKey] || this.state[localKey].getTime() !== update[key].getTime()) {
                        this.state[localKey] = update[key];
                        updateReasons.push(localKey);
                    }
                } else if (this[localKey] !== update[key]) {
                    this.state[localKey] = update[key];
                    updateReasons.push(localKey);
                }
            }
            if (updateReasons.length > 0) {
                this.emit('updated', { channel: this, updateReasons: updateReasons });
            }
        }
        /**
         * @private
         */

    }, {
        key: "_onMessageAdded",
        value: function _onMessageAdded(message) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
                for (var _iterator = (0, _getIterator3.default)(this.members.values()), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                    var member = _step.value;

                    if (member.identity === message.author) {
                        member._endTyping();
                        break;
                    }
                }
            } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
            } finally {
                try {
                    if (!_iteratorNormalCompletion && _iterator.return) {
                        _iterator.return();
                    }
                } finally {
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                }
            }

            this.emit('messageAdded', message);
        }
        /**
         * Add a participant to the Channel by its Identity.
         * @param {String} identity - Identity of the Client to add
         * @returns {Promise<void|Error|SessionError>}
         */

    }, {
        key: "add",
        value: function add(identity) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                if (!(!identity || typeof identity !== 'string')) {
                                    _context3.next = 2;
                                    break;
                                }

                                throw new Error('Channel.add requires an <String>identity parameter');

                            case 2:
                                return _context3.abrupt("return", this.membersEntity.add(identity));

                            case 3:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));
        }
        /**
         * Advance last consumed Channel's Message index to current consumption horizon.
         * Rejects if User is not Member of Channel.
         * Last consumed Message index is updated only if new index value is higher than previous.
         * @param {Number} index - Message index to advance to as last read
         * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
         */

    }, {
        key: "advanceLastConsumedMessageIndex",
        value: function advanceLastConsumedMessageIndex(index) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                if ((0, _isInteger2.default)(index)) {
                                    _context4.next = 2;
                                    break;
                                }

                                throw new Error('Channel.advanceLastConsumedMessageIndex requires an integral <Number>index parameter');

                            case 2:
                                _context4.next = 4;
                                return this._subscribeStreams();

                            case 4:
                                return _context4.abrupt("return", this.services.consumptionHorizon.advanceLastConsumedMessageIndexForChannel(this.sid, index, this.lastConsumedMessageIndex));

                            case 5:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));
        }
        /**
         * Decline an invitation to the Channel and unsubscribe from its events.
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "decline",
        value: function decline() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee5() {
                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                _context5.next = 2;
                                return this.services.session.addCommand('declineInvitation', {
                                    channelSid: this.sid
                                });

                            case 2:
                                return _context5.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this);
            }));
        }
        /**
         * Delete the Channel and unsubscribe from its events.
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "delete",
        value: function _delete() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee6() {
                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                _context6.next = 2;
                                return this.services.session.addCommand('destroyChannel', {
                                    channelSid: this.sid
                                });

                            case 2:
                                return _context6.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));
        }
        /**
         * Get the custom attributes of this Channel.<br/>
         *
         * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>
         * @returns {Promise<Object>}
         */

    }, {
        key: "getAttributes",
        value: function getAttributes() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee7() {
                return _regenerator2.default.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                _context7.next = 2;
                                return this._subscribe();

                            case 2:
                                return _context7.abrupt("return", this.attributes);

                            case 3:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));
        }
        /**
         * Returns messages from channel using paginator interface.
         * @param {Number} [pageSize=30] Number of messages to return in single chunk
         * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
         * @param {String} [direction=backwards] - Query direction. By default it query backwards
         *                                         from newer to older. 'forward' will query in opposite direction
         * @returns {Promise<Paginator<Message>>} page of messages
         */

    }, {
        key: "getMessages",
        value: function getMessages(pageSize, anchor, direction) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee8() {
                return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                        switch (_context8.prev = _context8.next) {
                            case 0:
                                if (!(typeof anchor !== 'undefined' && !(0, _isInteger2.default)(anchor))) {
                                    _context8.next = 2;
                                    break;
                                }

                                throw new Error('Anchor should be a valid message index');

                            case 2:
                                _context8.next = 4;
                                return this._subscribeStreams();

                            case 4:
                                return _context8.abrupt("return", this.messagesEntity.getMessages(pageSize, anchor, direction));

                            case 5:
                            case "end":
                                return _context8.stop();
                        }
                    }
                }, _callee8, this);
            }));
        }
        /**
         * Get a list of all Members joined to this Channel.
         * @returns {Promise<Array<Member>>}
         */

    }, {
        key: "getMembers",
        value: function getMembers() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee9() {
                return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                        switch (_context9.prev = _context9.next) {
                            case 0:
                                _context9.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context9.abrupt("return", this.membersEntity.getMembers());

                            case 3:
                            case "end":
                                return _context9.stop();
                        }
                    }
                }, _callee9, this);
            }));
        }
        /**
         * Get channel members count.
         * @returns {Promise<number|Error>}
         */

    }, {
        key: "getMembersCount",
        value: function getMembersCount() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee10() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee10$(_context10) {
                    while (1) {
                        switch (_context10.prev = _context10.next) {
                            case 0:
                                _context10.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context10.sent;
                                url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
                                _context10.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context10.sent;
                                return _context10.abrupt("return", response.body.members_count);

                            case 8:
                            case "end":
                                return _context10.stop();
                        }
                    }
                }, _callee10, this);
            }));
        }
        /**
         * Get total message count in a channel.
         * @returns {Promise<number|Error>}
         */

    }, {
        key: "getMessagesCount",
        value: function getMessagesCount() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee11() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee11$(_context11) {
                    while (1) {
                        switch (_context11.prev = _context11.next) {
                            case 0:
                                _context11.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context11.sent;
                                url = new util_1.UriBuilder(links.publicChannelsUrl).path(this.sid).build();
                                _context11.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context11.sent;
                                return _context11.abrupt("return", response.body.messages_count);

                            case 8:
                            case "end":
                                return _context11.stop();
                        }
                    }
                }, _callee11, this);
            }));
        }
        /**
         * Get unconsumed messages count for User if he is Member of this Channel.
         * Rejects if User is not Member of Channel.
         * @returns {Promise<number|Error>}
         */

    }, {
        key: "getUnconsumedMessagesCount",
        value: function getUnconsumedMessagesCount() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee12() {
                var links, url, response;
                return _regenerator2.default.wrap(function _callee12$(_context12) {
                    while (1) {
                        switch (_context12.prev = _context12.next) {
                            case 0:
                                _context12.next = 2;
                                return this.services.session.getSessionLinks();

                            case 2:
                                links = _context12.sent;
                                url = new util_1.UriBuilder(links.myChannelsUrl).arg('ChannelSid', this.sid).build();
                                _context12.next = 6;
                                return this.services.network.get(url);

                            case 6:
                                response = _context12.sent;

                                if (!(response.body.channels.length && response.body.channels[0].channel_sid == this.sid)) {
                                    _context12.next = 11;
                                    break;
                                }

                                if (!(typeof response.body.channels[0].unread_messages_count !== 'undefined' && response.body.channels[0].unread_messages_count != null)) {
                                    _context12.next = 10;
                                    break;
                                }

                                return _context12.abrupt("return", response.body.channels[0].unread_messages_count);

                            case 10:
                                return _context12.abrupt("return", null);

                            case 11:
                                throw new Error('Channel is not in user channels list');

                            case 12:
                            case "end":
                                return _context12.stop();
                        }
                    }
                }, _callee12, this);
            }));
        }
        /**
         * Invite a user to the Channel by their Identity.
         * @param {String} identity - Identity of the user to invite
         * @returns {Promise<void|Error|SessionError>}
         */

    }, {
        key: "invite",
        value: function invite(identity) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee13() {
                return _regenerator2.default.wrap(function _callee13$(_context13) {
                    while (1) {
                        switch (_context13.prev = _context13.next) {
                            case 0:
                                if (!(typeof identity !== 'string' || !identity.length)) {
                                    _context13.next = 2;
                                    break;
                                }

                                throw new Error('Channel.invite requires an <String>identity parameter');

                            case 2:
                                return _context13.abrupt("return", this.membersEntity.invite(identity));

                            case 3:
                            case "end":
                                return _context13.stop();
                        }
                    }
                }, _callee13, this);
            }));
        }
        /**
         * Join the Channel and subscribe to its events.
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "join",
        value: function join() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee14() {
                return _regenerator2.default.wrap(function _callee14$(_context14) {
                    while (1) {
                        switch (_context14.prev = _context14.next) {
                            case 0:
                                _context14.next = 2;
                                return this.services.session.addCommand('joinChannelV2', { channelSid: this.sid });

                            case 2:
                                return _context14.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context14.stop();
                        }
                    }
                }, _callee14, this);
            }));
        }
        /**
         * Leave the Channel.
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "leave",
        value: function leave() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee15() {
                return _regenerator2.default.wrap(function _callee15$(_context15) {
                    while (1) {
                        switch (_context15.prev = _context15.next) {
                            case 0:
                                if (!(this.state.status === 'joined')) {
                                    _context15.next = 3;
                                    break;
                                }

                                _context15.next = 3;
                                return this.services.session.addCommand('leaveChannel', { channelSid: this.sid });

                            case 3:
                                return _context15.abrupt("return", this);

                            case 4:
                            case "end":
                                return _context15.stop();
                        }
                    }
                }, _callee15, this);
            }));
        }
        /**
         * Remove a Member from the Channel.
         * @param {String} member - identity of member to remove
         * @returns {Promise<void|Error|SessionError>}
         */

    }, {
        key: "removeMember",
        value: function removeMember(member) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee16() {
                return _regenerator2.default.wrap(function _callee16$(_context16) {
                    while (1) {
                        switch (_context16.prev = _context16.next) {
                            case 0:
                                if (!(!member || typeof member !== 'string' && !(member instanceof member_1.Member))) {
                                    _context16.next = 2;
                                    break;
                                }

                                throw new Error('Channel.removeMember requires a <String|Member>member parameter.');

                            case 2:
                                return _context16.abrupt("return", this.membersEntity.remove(typeof member === 'string' ? member : member.identity));

                            case 3:
                            case "end":
                                return _context16.stop();
                        }
                    }
                }, _callee16, this);
            }));
        }
        /**
         * Send a Message in the Channel.
         * @param {String | FormData | Channel#SendMediaOptions} message - The message body for text message,
         * FormData or MediaOptions for media content
         * @param {Object} messageAttributes - attributes for the message
         * @returns {Promise<number|Error|SessionError>} new Message's index in the Channel's messages list
         */

    }, {
        key: "sendMessage",
        value: function sendMessage(message, messageAttributes) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee17() {
                var response, _response;

                return _regenerator2.default.wrap(function _callee17$(_context17) {
                    while (1) {
                        switch (_context17.prev = _context17.next) {
                            case 0:
                                if (!(typeof message === 'undefined')) {
                                    _context17.next = 2;
                                    break;
                                }

                                throw new Error('Message is required parameter');

                            case 2:
                                if (!(typeof message === 'string' || message === null)) {
                                    _context17.next = 9;
                                    break;
                                }

                                _context17.next = 5;
                                return this.messagesEntity.send(message, messageAttributes);

                            case 5:
                                response = _context17.sent;
                                return _context17.abrupt("return", util_1.parseToNumber(response.messageId));

                            case 9:
                                _context17.next = 11;
                                return this.messagesEntity.sendMedia(message, messageAttributes);

                            case 11:
                                _response = _context17.sent;
                                return _context17.abrupt("return", util_1.parseToNumber(_response.messageId));

                            case 13:
                            case "end":
                                return _context17.stop();
                        }
                    }
                }, _callee17, this);
            }));
        }
        /**
         * Set last consumed Channel's Message index to last known Message's index in this Channel.
         * @returns {Promise<number|SessionError>} resulting unread messages count in the channel
         */

    }, {
        key: "setAllMessagesConsumed",
        value: function setAllMessagesConsumed() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee18() {
                var messagesPage;
                return _regenerator2.default.wrap(function _callee18$(_context18) {
                    while (1) {
                        switch (_context18.prev = _context18.next) {
                            case 0:
                                _context18.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                _context18.next = 4;
                                return this.getMessages(1);

                            case 4:
                                messagesPage = _context18.sent;

                                if (!(messagesPage.items.length > 0)) {
                                    _context18.next = 7;
                                    break;
                                }

                                return _context18.abrupt("return", this.advanceLastConsumedMessageIndex(messagesPage.items[0].index));

                            case 7:
                                return _context18.abrupt("return", _promise2.default.resolve(0));

                            case 8:
                            case "end":
                                return _context18.stop();
                        }
                    }
                }, _callee18, this);
            }));
        }
        /**
         * Set all messages in the channel unread.
         * @returns {Promise<number|SessionError>} resulting unread messages count in the channel
         */

    }, {
        key: "setNoMessagesConsumed",
        value: function setNoMessagesConsumed() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee19() {
                return _regenerator2.default.wrap(function _callee19$(_context19) {
                    while (1) {
                        switch (_context19.prev = _context19.next) {
                            case 0:
                                _context19.next = 2;
                                return this._subscribeStreams();

                            case 2:
                                return _context19.abrupt("return", this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, null));

                            case 3:
                            case "end":
                                return _context19.stop();
                        }
                    }
                }, _callee19, this);
            }));
        }
        /**
         * Set User Notification level for this channel.
         * @param {Channel#NotificationLevel} notificationLevel - The new user notification level
         * @returns {Promise<void|Error|SessionError>}
         */

    }, {
        key: "setUserNotificationLevel",
        value: function setUserNotificationLevel(notificationLevel) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee20() {
                return _regenerator2.default.wrap(function _callee20$(_context20) {
                    while (1) {
                        switch (_context20.prev = _context20.next) {
                            case 0:
                                if (notificationLevel) {
                                    _context20.next = 2;
                                    break;
                                }

                                throw new Error('notificationLevel can\'t be null');

                            case 2:
                                _context20.next = 4;
                                return this.services.session.addCommand('editNotificationLevel', { channelSid: this.sid, notificationLevel: notificationLevel });

                            case 4:
                            case "end":
                                return _context20.stop();
                        }
                    }
                }, _callee20, this);
            }));
        }
        /**
         * Send a notification to the server indicating that this Client is currently typing in this Channel.
         * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
         * @returns {Promise<void|SessionError>}
         */

    }, {
        key: "typing",
        value: function typing() {
            return this.services.typingIndicator.send(this.sid);
        }
        /**
         * Update the Channel's attributes.
         * @param {Object} attributes - The new attributes object
         * @returns {Promise<Channel|Error|SessionError>}
         */

    }, {
        key: "updateAttributes",
        value: function updateAttributes(attributes) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee21() {
                return _regenerator2.default.wrap(function _callee21$(_context21) {
                    while (1) {
                        switch (_context21.prev = _context21.next) {
                            case 0:
                                if (!(typeof attributes === 'undefined')) {
                                    _context21.next = 4;
                                    break;
                                }

                                throw new Error('Attributes is required parameter');

                            case 4:
                                if (!(attributes === null)) {
                                    _context21.next = 8;
                                    break;
                                }

                                throw new Error('Attributes can\'t be null');

                            case 8:
                                if (!(attributes.constructor !== Object)) {
                                    _context21.next = 10;
                                    break;
                                }

                                throw new Error('Attributes must be a valid JSON object.');

                            case 10:
                                _context21.next = 12;
                                return this.services.session.addCommand('editAttributes', {
                                    channelSid: this.sid,
                                    attributes: (0, _stringify2.default)(attributes)
                                });

                            case 12:
                                return _context21.abrupt("return", this);

                            case 13:
                            case "end":
                                return _context21.stop();
                        }
                    }
                }, _callee21, this);
            }));
        }
        /**
         * Update the Channel's friendlyName.
         * @param {String} name - The new Channel friendlyName
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "updateFriendlyName",
        value: function updateFriendlyName(name) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee22() {
                return _regenerator2.default.wrap(function _callee22$(_context22) {
                    while (1) {
                        switch (_context22.prev = _context22.next) {
                            case 0:
                                if (!(this.state.friendlyName !== name)) {
                                    _context22.next = 3;
                                    break;
                                }

                                _context22.next = 3;
                                return this.services.session.addCommand('editFriendlyName', {
                                    channelSid: this.sid,
                                    friendlyName: name
                                });

                            case 3:
                                return _context22.abrupt("return", this);

                            case 4:
                            case "end":
                                return _context22.stop();
                        }
                    }
                }, _callee22, this);
            }));
        }
        /**
         * Set last consumed Channel's Message index to current consumption horizon.
         * @param {Number|null} index - Message index to set as last read.
         * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}
         * @returns {Promise<number|Error|SessionError>} resulting unread messages count in the channel
         */

    }, {
        key: "updateLastConsumedMessageIndex",
        value: function updateLastConsumedMessageIndex(index) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee23() {
                return _regenerator2.default.wrap(function _callee23$(_context23) {
                    while (1) {
                        switch (_context23.prev = _context23.next) {
                            case 0:
                                if ((0, _isInteger2.default)(index) || index === null) {
                                    _context23.next = 2;
                                    break;
                                }

                                throw new Error('Incorrect argument "index": integer number or null expected');

                            case 2:
                                _context23.next = 4;
                                return this._subscribeStreams();

                            case 4:
                                return _context23.abrupt("return", this.services.consumptionHorizon.updateLastConsumedMessageIndexForChannel(this.sid, index));

                            case 5:
                            case "end":
                                return _context23.stop();
                        }
                    }
                }, _callee23, this);
            }));
        }
        /**
         * Update the Channel's unique name.
         * @param {String} uniqueName - The new Channel uniqueName
         * @returns {Promise<Channel|SessionError>}
         */

    }, {
        key: "updateUniqueName",
        value: function updateUniqueName(uniqueName) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee24() {
                return _regenerator2.default.wrap(function _callee24$(_context24) {
                    while (1) {
                        switch (_context24.prev = _context24.next) {
                            case 0:
                                if (!(this.state.uniqueName !== uniqueName)) {
                                    _context24.next = 4;
                                    break;
                                }

                                if (!uniqueName) {
                                    uniqueName = '';
                                }
                                _context24.next = 4;
                                return this.services.session.addCommand('editUniqueName', {
                                    channelSid: this.sid,
                                    uniqueName: uniqueName
                                });

                            case 4:
                                return _context24.abrupt("return", this);

                            case 5:
                            case "end":
                                return _context24.stop();
                        }
                    }
                }, _callee24, this);
            }));
        }
        /**
         * Gets User Descriptors for this channel.
         * @returns {Promise<Paginator<UserDescriptor>>}
         */

    }, {
        key: "getUserDescriptors",
        value: function getUserDescriptors() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee25() {
                return _regenerator2.default.wrap(function _callee25$(_context25) {
                    while (1) {
                        switch (_context25.prev = _context25.next) {
                            case 0:
                                return _context25.abrupt("return", this.services.users.getChannelUserDescriptors(this.sid));

                            case 1:
                            case "end":
                                return _context25.stop();
                        }
                    }
                }, _callee25, this);
            }));
        }
    }, {
        key: "status",
        get: function get() {
            return this.state.status;
        }
    }, {
        key: "type",
        get: function get() {
            return this.state.type;
        }
    }, {
        key: "uniqueName",
        get: function get() {
            return this.state.uniqueName;
        }
    }, {
        key: "isPrivate",
        get: function get() {
            return this.state.type === 'private';
        }
    }, {
        key: "friendlyName",
        get: function get() {
            return this.state.friendlyName;
        }
    }, {
        key: "dateUpdated",
        get: function get() {
            return this.state.dateUpdated;
        }
    }, {
        key: "dateCreated",
        get: function get() {
            return this.state.dateCreated;
        }
    }, {
        key: "createdBy",
        get: function get() {
            return this.state.createdBy;
        }
    }, {
        key: "attributes",
        get: function get() {
            return this.state.attributes;
        }
    }, {
        key: "lastConsumedMessageIndex",
        get: function get() {
            return this.state.lastConsumedMessageIndex;
        }
    }, {
        key: "lastMessage",
        get: function get() {
            return this.state.lastMessage;
        }
    }, {
        key: "notificationLevel",
        get: function get() {
            return this.state.notificationLevel;
        }
    }], [{
        key: "preprocessUpdate",
        value: function preprocessUpdate(update, channelSid) {
            try {
                if (typeof update.attributes === 'string') {
                    update.attributes = JSON.parse(update.attributes);
                } else if (update.attributes) {
                    (0, _stringify2.default)(update.attributes);
                }
            } catch (e) {
                log.warn('Retrieved malformed attributes from the server for channel: ' + channelSid);
                update.attributes = {};
            }
            try {
                if (update.dateCreated) {
                    update.dateCreated = new Date(update.dateCreated);
                }
            } catch (e) {
                log.warn('Retrieved malformed dateCreated from the server for channel: ' + channelSid);
                delete update.dateCreated;
            }
            try {
                if (update.dateUpdated) {
                    update.dateUpdated = new Date(update.dateUpdated);
                }
            } catch (e) {
                log.warn('Retrieved malformed dateUpdated from the server for channel: ' + channelSid);
                delete update.dateUpdated;
            }
            try {
                if (update.lastMessage && update.lastMessage.timestamp) {
                    update.lastMessage.timestamp = new Date(update.lastMessage.timestamp);
                }
            } catch (e) {
                log.warn('Retrieved malformed lastMessage.timestamp from the server for channel: ' + channelSid);
                delete update.lastMessage.timestamp;
            }
        }
    }]);
    return Channel;
}(events_1.EventEmitter);

exports.Channel = Channel;
/**
 * Fired when a Member has joined the Channel.
 * @event Channel#memberJoined
 * @type {Member}
 */
/**
 * Fired when a Member has left the Channel.
 * @event Channel#memberLeft
 * @type {Member}
 */
/**
 * Fired when a Member's fields has been updated.
 * @event Channel#memberUpdated
 * @type {Object}
 * @property {Member} member - Updated Member
 * @property {Member#UpdateReason[]} updateReasons - Array of Member's updated event reasons
 */
/**
 * Fired when a new Message has been added to the Channel.
 * @event Channel#messageAdded
 * @type {Message}
 */
/**
 * Fired when Message is removed from Channel's message list.
 * @event Channel#messageRemoved
 * @type {Message}
 */
/**
 * Fired when an existing Message's fields are updated with new values.
 * @event Channel#messageUpdated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */
/**
 * Fired when a Member has stopped typing.
 * @event Channel#typingEnded
 * @type {Member}
 */
/**
 * Fired when a Member has started typing.
 * @event Channel#typingStarted
 * @type {Member}
 */
/**
 * Fired when a Channel's attributes or metadata have been updated.
 * During Channel's {@link Client.create | creation and initialization} this event might be fired multiple times
 * for same joined or created Channel as new data is arriving from different sources.
 * @event Channel#updated
 * @type {Object}
 * @property {Channel} channel - Updated Channel
 * @property {Channel#UpdateReason[]} updateReasons - Array of Channel's updated event reasons
 */