"use strict";

var _stringify = require("babel-runtime/core-js/json/stringify");

var _stringify2 = _interopRequireDefault(_stringify);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = _promise2.default))(function (resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : new P(function (resolve) {
                resolve(result.value);
            }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var index_1 = require("./util/index");
var logger_1 = require("./logger");
var media_1 = require("./media");
var log = logger_1.Logger.scope('Message');
function parseAttributes(msgSid, attributes) {
    try {
        return attributes ? JSON.parse(attributes) : {};
    } catch (e) {
        log.warn('Got malformed attributes for the message', msgSid);
        return {};
    }
}
/**
 * @classdesc A Message represents a Message in a Channel.
 * @property {String} author - The name of the user that sent Message
 * @property {String} body - The body of the Message. Is null if Message is Media Message
 * @property {Object} attributes - Message custom attributes
 * @property {Channel} channel - Channel Message belongs to
 * @property {Date} dateUpdated - When Message was updated
 * @property {Number} index - Index of Message in the Channel's messages list
 * @property {String} lastUpdatedBy - Identity of the last user that updated Message
 * @property {Media} media - Contains Media information (if present)
 * @property {String} sid - The server-assigned unique identifier for Message
 * @property {Date} timestamp - When Message was created
 * @property {'text' | 'media' } type - Type of message: 'text' or 'media'
 * @fires Message#updated
 */

var Message = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Message, _events_1$EventEmitte);

    /**
     * The update reason for <code>updated</code> event emitted on Message
     * @typedef {('body' | 'lastUpdatedBy' | 'dateUpdated' | 'timestamp' | 'attributes' | 'author')} Message#UpdateReason
     */
    function Message(channel, services, index, data) {
        (0, _classCallCheck3.default)(this, Message);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Message.__proto__ || (0, _getPrototypeOf2.default)(Message)).call(this));

        _this.channel = channel;
        _this.services = services;
        _this.state = {
            sid: data.sid,
            index: index,
            author: data.author,
            body: data.text,
            timestamp: data.timestamp ? new Date(data.timestamp) : null,
            dateUpdated: data.dateUpdated ? new Date(data.dateUpdated) : null,
            lastUpdatedBy: data.lastUpdatedBy ? data.lastUpdatedBy : null,
            attributes: parseAttributes(data.sid, data.attributes),
            type: data.type ? data.type : 'text',
            media: data.type && data.type === 'media' && data.media ? new media_1.Media(data.media, _this.services) : null
        };
        return _this;
    }

    (0, _createClass3.default)(Message, [{
        key: "_update",
        value: function _update(data) {
            var updateReasons = [];
            if ((data.text || typeof data.text === 'string') && data.text !== this.state.body) {
                this.state.body = data.text;
                updateReasons.push('body');
            }
            if (data.lastUpdatedBy && data.lastUpdatedBy !== this.state.lastUpdatedBy) {
                this.state.lastUpdatedBy = data.lastUpdatedBy;
                updateReasons.push('lastUpdatedBy');
            }
            if (data.author && data.author !== this.state.author) {
                this.state.author = data.author;
                updateReasons.push('author');
            }
            if (data.dateUpdated && new Date(data.dateUpdated).getTime() !== (this.state.dateUpdated && this.state.dateUpdated.getTime())) {
                this.state.dateUpdated = new Date(data.dateUpdated);
                updateReasons.push('dateUpdated');
            }
            if (data.timestamp && new Date(data.timestamp).getTime() !== (this.state.timestamp && this.state.timestamp.getTime())) {
                this.state.timestamp = new Date(data.timestamp);
                updateReasons.push('timestamp');
            }
            var updatedAttributes = parseAttributes(this.sid, data.attributes);
            if (!index_1.isDeepEqual(this.state.attributes, updatedAttributes)) {
                this.state.attributes = updatedAttributes;
                updateReasons.push('attributes');
            }
            if (updateReasons.length > 0) {
                this.emit('updated', { message: this, updateReasons: updateReasons });
            }
        }
        /**
         * Remove the Message.
         * @returns {Promise<Message|SessionError>}
         */

    }, {
        key: "remove",
        value: function remove() {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.services.session.addCommand('deleteMessage', {
                                    channelSid: this.channel.sid,
                                    messageIdx: this.index.toString()
                                });

                            case 2:
                                return _context.abrupt("return", this);

                            case 3:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));
        }
        /**
         * Edit message body.
         * @param {String} body - new body of Message.
         * @returns {Promise<Message|Error|SessionError>}
         */

    }, {
        key: "updateBody",
        value: function updateBody(body) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (!(typeof body !== 'string')) {
                                    _context2.next = 2;
                                    break;
                                }

                                throw new Error('Body <String> is a required parameter for updateBody');

                            case 2:
                                _context2.next = 4;
                                return this.services.session.addCommand('editMessage', {
                                    channelSid: this.channel.sid,
                                    messageIdx: this.index.toString(),
                                    text: body
                                });

                            case 4:
                                return _context2.abrupt("return", this);

                            case 5:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));
        }
        /**
         * Edit message attributes.
         * @param {Object} attributes new attributes for Message.
         * @returns {Promise<Message|Error|SessionError>}
         */

    }, {
        key: "updateAttributes",
        value: function updateAttributes(attributes) {
            return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                if (!(typeof attributes === 'undefined')) {
                                    _context3.next = 4;
                                    break;
                                }

                                throw new Error('Attributes is required parameter');

                            case 4:
                                if (!(attributes === null)) {
                                    _context3.next = 8;
                                    break;
                                }

                                throw new Error('Attributes can\'t be null');

                            case 8:
                                if (!(attributes.constructor !== Object)) {
                                    _context3.next = 10;
                                    break;
                                }

                                throw new Error('Attributes must be a valid JSON object');

                            case 10:
                                _context3.next = 12;
                                return this.services.session.addCommand('editMessageAttributes', {
                                    channelSid: this.channel.sid,
                                    messageIdx: this.index,
                                    attributes: (0, _stringify2.default)(attributes)
                                });

                            case 12:
                                return _context3.abrupt("return", this);

                            case 13:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));
        }
    }, {
        key: "sid",
        get: function get() {
            return this.state.sid;
        }
    }, {
        key: "author",
        get: function get() {
            return this.state.author;
        }
    }, {
        key: "body",
        get: function get() {
            if (this.type === 'media') {
                return null;
            }
            return this.state.body;
        }
    }, {
        key: "dateUpdated",
        get: function get() {
            return this.state.dateUpdated;
        }
    }, {
        key: "index",
        get: function get() {
            return this.state.index;
        }
    }, {
        key: "lastUpdatedBy",
        get: function get() {
            return this.state.lastUpdatedBy;
        }
    }, {
        key: "timestamp",
        get: function get() {
            return this.state.timestamp;
        }
    }, {
        key: "attributes",
        get: function get() {
            return this.state.attributes;
        }
    }, {
        key: "type",
        get: function get() {
            return this.state.type;
        }
    }, {
        key: "media",
        get: function get() {
            return this.state.media;
        }
    }]);
    return Message;
}(events_1.EventEmitter);

exports.Message = Message;
/**
 * Fired when the Message's properties or body has been updated.
 * @event Message#updated
 * @type {Object}
 * @property {Message} message - Updated Message
 * @property {Message#UpdateReason[]} updateReasons - Array of Message's updated event reasons
 */